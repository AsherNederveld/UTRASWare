; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gpio.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I.. -I..\..\.. -I.\RTE\_Timers -IC:\Users\matth\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\matth\AppData\Local\Arm\Packs\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DTM4C123GH6PM -D_RTE_ -Drvmdk -DPART_LM4F120H5QR --omf_browse=.\objects\gpio.crf ..\..\..\lib\GPIO\GPIO.c]
                          THUMB

                          AREA ||i.GPIOGeneric_Handler||, CODE, READONLY, ALIGN=2

                  GPIOGeneric_Handler PROC
;;;259    /** Internal handler to manage GPIO interrupts. */
;;;260    void GPIOGeneric_Handler(pin_t pin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;261        /** 1. Generate the port offset to find the correct addresses.
;;;262         *    There are a couple components in this line:
;;;263         * 
;;;264         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;265         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;266         *    details.
;;;267         * 
;;;268         *    (((pin - XXX) >> 3) << 12) : 
;;;269         *          Every group of eight pins belongs to the same port, and every
;;;270         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;271         *          in the datasheet). This expression right shifts the pin to mask
;;;272         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;273         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;274         *          GPIO_PORT_BASE to get the port address.
;;;275         * 
;;;276         *          The term `- XXX` is a conditional expanded to the following:
;;;277         * 
;;;278         *                        XXX = ((pin >= PIN_E0) << 5)
;;;279         * 
;;;280         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;281         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;282         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;283         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;284         * 
;;;285         *    + (pin >= PIN_E0) << 17 : 
;;;286         *          Port E and F are special in that they requires an
;;;287         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;288         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;289         */
;;;290        uint32_t portOffset = 
000006  2e20              CMP      r6,#0x20
000008  db01              BLT      |L1.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L1.16|
                  |L1.14|
00000e  2000              MOVS     r0,#0
                  |L1.16|
000010  eba61040          SUB      r0,r6,r0,LSL #5
000014  10c0              ASRS     r0,r0,#3
000016  0300              LSLS     r0,r0,#12
000018  2e20              CMP      r6,#0x20
00001a  db01              BLT      |L1.32|
00001c  2101              MOVS     r1,#1
00001e  e000              B        |L1.34|
                  |L1.32|
000020  2100              MOVS     r1,#0
                  |L1.34|
000022  eb004741          ADD      r7,r0,r1,LSL #17
;;;291            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;292    
;;;293        /* 2. Find which pin triggered an interrupt. Could be multiple at once. */
;;;294        uint8_t i;
;;;295        for (i = 0; i < 8; i++) {
000026  2500              MOVS     r5,#0
000028  e064              B        |L1.244|
                  |L1.42|
;;;296            if (GET_REG(GPIO_PORT_BASE + portOffset + GPIO_MIS_OFFSET) & (0x1 << i)) {
00002a  4834              LDR      r0,|L1.252|
00002c  59c0              LDR      r0,[r0,r7]
00002e  2101              MOVS     r1,#1
000030  40a9              LSLS     r1,r1,r5
000032  4008              ANDS     r0,r0,r1
000034  2800              CMP      r0,#0
000036  d05b              BEQ      |L1.240|
;;;297                /* Acknowledge interrupt flag. */
;;;298                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ICR_OFFSET) |= 0x1 << i;
000038  4830              LDR      r0,|L1.252|
00003a  1d00              ADDS     r0,r0,#4
00003c  59c1              LDR      r1,[r0,r7]
00003e  2001              MOVS     r0,#1
000040  40a8              LSLS     r0,r0,r5
000042  4308              ORRS     r0,r0,r1
000044  492d              LDR      r1,|L1.252|
000046  1d09              ADDS     r1,r1,#4
000048  51c8              STR      r0,[r1,r7]
;;;299                
;;;300                /* Get pin number. */
;;;301                pin_t pinIdx = (pin_t)(pin + i);
00004a  1970              ADDS     r0,r6,r5
00004c  b2c4              UXTB     r4,r0
;;;302    
;;;303                if (GPIOIntConfig[pinIdx].touchTask != NULL && GPIOIntConfig[pinIdx].releaseTask != NULL) {
00004e  482c              LDR      r0,|L1.256|
000050  eb001004          ADD      r0,r0,r4,LSL #4
000054  6840              LDR      r0,[r0,#4]
000056  b378              CBZ      r0,|L1.184|
000058  4829              LDR      r0,|L1.256|
00005a  eb001004          ADD      r0,r0,r4,LSL #4
00005e  6880              LDR      r0,[r0,#8]
000060  b350              CBZ      r0,|L1.184|
;;;304                    /* Both edge triggered. */
;;;305                    /* Get pin status. */
;;;306                    bool status = GPIOGetBit(pinIdx);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       GPIOGetBit
000068  4680              MOV      r8,r0
;;;307                    /* Figure out if rising or falling edge by reading the data register. */
;;;308                    if (status == 1 && GPIOIntConfig[pinIdx].pinStatus == LOWERED) {
00006a  f1b80f00          CMP      r8,#0
00006e  d00f              BEQ      |L1.144|
000070  4823              LDR      r0,|L1.256|
000072  eb001004          ADD      r0,r0,r4,LSL #4
000076  7b00              LDRB     r0,[r0,#0xc]
000078  b950              CBNZ     r0,|L1.144|
;;;309                        /* Rising edge. */
;;;310                        GPIOIntConfig[pinIdx].touchTask();
00007a  4921              LDR      r1,|L1.256|
00007c  eb011104          ADD      r1,r1,r4,LSL #4
000080  6848              LDR      r0,[r1,#4]
000082  4780              BLX      r0
;;;311                        GPIOIntConfig[pinIdx].pinStatus = RAISED;
000084  2001              MOVS     r0,#1
000086  491e              LDR      r1,|L1.256|
000088  eb011104          ADD      r1,r1,r4,LSL #4
00008c  7308              STRB     r0,[r1,#0xc]
00008e  e012              B        |L1.182|
                  |L1.144|
;;;312                    } else if (status == 0 && GPIOIntConfig[pinIdx].pinStatus == RAISED){
000090  f1b80f00          CMP      r8,#0
000094  d10f              BNE      |L1.182|
000096  481a              LDR      r0,|L1.256|
000098  eb001004          ADD      r0,r0,r4,LSL #4
00009c  7b00              LDRB     r0,[r0,#0xc]
00009e  2801              CMP      r0,#1
0000a0  d109              BNE      |L1.182|
;;;313                        /* Falling edge. */
;;;314                        GPIOIntConfig[pinIdx].releaseTask();
0000a2  4917              LDR      r1,|L1.256|
0000a4  eb011104          ADD      r1,r1,r4,LSL #4
0000a8  6888              LDR      r0,[r1,#8]
0000aa  4780              BLX      r0
;;;315                        GPIOIntConfig[pinIdx].pinStatus = LOWERED;
0000ac  2000              MOVS     r0,#0
0000ae  4914              LDR      r1,|L1.256|
0000b0  eb011104          ADD      r1,r1,r4,LSL #4
0000b4  7308              STRB     r0,[r1,#0xc]
                  |L1.182|
;;;316                    }
;;;317                } else if (GPIOIntConfig[pinIdx].touchTask != NULL) {
0000b6  e01a              B        |L1.238|
                  |L1.184|
0000b8  e7ff              B        |L1.186|
                  |L1.186|
0000ba  4811              LDR      r0,|L1.256|
0000bc  eb001004          ADD      r0,r0,r4,LSL #4
0000c0  6840              LDR      r0,[r0,#4]
0000c2  b150              CBZ      r0,|L1.218|
;;;318                    /* Rising edge trigger. */
;;;319                    GPIOIntConfig[pinIdx].touchTask();
0000c4  490e              LDR      r1,|L1.256|
0000c6  eb011104          ADD      r1,r1,r4,LSL #4
0000ca  6848              LDR      r0,[r1,#4]
0000cc  4780              BLX      r0
;;;320                    GPIOIntConfig[pinIdx].pinStatus = RAISED;
0000ce  2001              MOVS     r0,#1
0000d0  490b              LDR      r1,|L1.256|
0000d2  eb011104          ADD      r1,r1,r4,LSL #4
0000d6  7308              STRB     r0,[r1,#0xc]
0000d8  e009              B        |L1.238|
                  |L1.218|
;;;321                } else {
;;;322                    /* Falling edge trigger. */
;;;323                    GPIOIntConfig[pinIdx].releaseTask();
0000da  4909              LDR      r1,|L1.256|
0000dc  eb011104          ADD      r1,r1,r4,LSL #4
0000e0  6888              LDR      r0,[r1,#8]
0000e2  4780              BLX      r0
;;;324                    GPIOIntConfig[pinIdx].pinStatus = LOWERED;
0000e4  2000              MOVS     r0,#0
0000e6  4906              LDR      r1,|L1.256|
0000e8  eb011104          ADD      r1,r1,r4,LSL #4
0000ec  7308              STRB     r0,[r1,#0xc]
                  |L1.238|
;;;325                }
;;;326            }
0000ee  bf00              NOP      
                  |L1.240|
0000f0  1c68              ADDS     r0,r5,#1              ;295
0000f2  b2c5              UXTB     r5,r0                 ;295
                  |L1.244|
0000f4  2d08              CMP      r5,#8                 ;295
0000f6  db98              BLT      |L1.42|
;;;327        }
;;;328    }
0000f8  e8bd81f0          POP      {r4-r8,pc}
;;;329    
                          ENDP

                  |L1.252|
                          DCD      0x40004418
                  |L1.256|
                          DCD      GPIOIntConfig

                          AREA ||i.GPIOGetBit||, CODE, READONLY, ALIGN=1

                  GPIOGetBit PROC
;;;695     */
;;;696    bool GPIOGetBit(pin_t pin) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;697        /* Early return on invalid pin_t value. */
;;;698        if (pin >= PIN_COUNT) return 0;
000004  2930              CMP      r1,#0x30
000006  db01              BLT      |L2.12|
000008  2000              MOVS     r0,#0
                  |L2.10|
;;;699    
;;;700        /** 1. Generate the port offset to find the correct addresses.
;;;701         *    There are a couple components in this line:
;;;702         * 
;;;703         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;704         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;705         *    details.
;;;706         * 
;;;707         *    (((pin - XXX >> 3) << 12) : 
;;;708         *          Every group of eight pins belongs to the same port, and every
;;;709         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;710         *          in the datasheet). This expression right shifts the pin to mask
;;;711         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;712         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;713         *          GPIO_PORT_BASE to get the port address.
;;;714         * 
;;;715         *          The term `- XXX` is a conditional expanded to the following:
;;;716         * 
;;;717         *                        XXX = ((pin >= PIN_E0) << 5)
;;;718         * 
;;;719         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;720         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;721         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;722         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;723         * 
;;;724         *    + (pin >= PIN_E0) << 17 : 
;;;725         *          Port E and F are special in that they requires an
;;;726         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;727         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;728         */
;;;729        uint32_t portOffset = 
;;;730            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;731    
;;;732        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;733        return GET_REG(GPIO_PORT_BASE + portOffset + (1 << ((pin & 0x07) + 2)));
;;;734    }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  2920              CMP      r1,#0x20              ;729
00000e  db01              BLT      |L2.20|
000010  2001              MOVS     r0,#1                 ;729
000012  e000              B        |L2.22|
                  |L2.20|
000014  2000              MOVS     r0,#0                 ;729
                  |L2.22|
000016  eba11040          SUB      r0,r1,r0,LSL #5       ;729
00001a  10c0              ASRS     r0,r0,#3              ;729
00001c  0300              LSLS     r0,r0,#12             ;729
00001e  2920              CMP      r1,#0x20              ;729
000020  db01              BLT      |L2.38|
000022  2301              MOVS     r3,#1                 ;729
000024  e000              B        |L2.40|
                  |L2.38|
000026  2300              MOVS     r3,#0                 ;729
                  |L2.40|
000028  eb004243          ADD      r2,r0,r3,LSL #17      ;729
00002c  f1022040          ADD      r0,r2,#0x40004000     ;733
000030  f0010307          AND      r3,r1,#7              ;733
000034  1c9b              ADDS     r3,r3,#2              ;733
000036  2401              MOVS     r4,#1                 ;733
000038  409c              LSLS     r4,r4,r3              ;733
00003a  5900              LDR      r0,[r0,r4]            ;733
00003c  b108              CBZ      r0,|L2.66|
00003e  2001              MOVS     r0,#1                 ;733
000040  e7e3              B        |L2.10|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;733
000044  e7e1              B        |L2.10|
;;;735    #endif
                          ENDP


                          AREA ||i.GPIOInit||, CODE, READONLY, ALIGN=2

                  GPIOInit PROC
;;;65      */
;;;66     void GPIOInit(GPIOConfig_t pinConfig) {
000000  e92d47f3          PUSH     {r0,r1,r4-r10,lr}
;;;67         /* Early return on invalid pin_t value. */
;;;68         if (pinConfig.GPIOPin >= PIN_COUNT) return;
000004  f89d0000          LDRB     r0,[sp,#0]
000008  2830              CMP      r0,#0x30
00000a  db01              BLT      |L3.16|
                  |L3.12|
;;;69     
;;;70         /* 1. Activate the clock for the relevant port. */
;;;71         GET_REG(SYSCTL_BASE + SYSCTL_RCGCGPIO_OFFSET) |= 
;;;72             1 << (pinConfig.GPIOPin / 8); /* 8 pins per port. */
;;;73     
;;;74         /* 2. Stall until clock is ready. */
;;;75         while ((GET_REG(SYSCTL_BASE + SYSCTL_PRGPIO_OFFSET) & 
;;;76                (1 << (pinConfig.GPIOPin / 8))) == 0) {};
;;;77     
;;;78         /** 3. Generate the port offset to find the correct addresses.
;;;79          *    There are a couple components in this line:
;;;80          * 
;;;81          *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;82          *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;83          *    details.
;;;84          * 
;;;85          *    (((pin - XXX) >> 3) << 12) : 
;;;86          *          Every group of eight pins belongs to the same port, and every
;;;87          *          port has an offset of 0x1000 from each other (typically) (p.685
;;;88          *          in the datasheet). This expression right shifts the pin to mask
;;;89          *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;90          *          the offset (1 << 12 is 0x1000). This is later appended to
;;;91          *          GPIO_PORT_BASE to get the port address.
;;;92          * 
;;;93          *          The term `- XXX` is a conditional expanded to the following:
;;;94          * 
;;;95          *                        XXX = ((pin >= PIN_E0) << 5)
;;;96          * 
;;;97          *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;98          *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;99          *          enum value of PIN_E0) to get the correct port offset. This is 
;;;100         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;101         * 
;;;102         *    + (pin >= PIN_E0) << 17 : 
;;;103         *          Port E and F are special in that they requires an
;;;104         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;105         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;106         */
;;;107        uint32_t portOffset = 
;;;108            (((pinConfig.GPIOPin - ((pinConfig.GPIOPin >= PIN_E0) << 5)) >> 3) << 12) + 
;;;109            ((pinConfig.GPIOPin >= PIN_E0) << 17);
;;;110    
;;;111        /* 4. If PC0-3, PD7, PF0, unlock the port. */
;;;112        if (pinConfig.GPIOPin == PIN_C0 ||
;;;113            pinConfig.GPIOPin == PIN_C1 ||
;;;114            pinConfig.GPIOPin == PIN_C2 ||
;;;115            pinConfig.GPIOPin == PIN_C3 ||
;;;116            pinConfig.GPIOPin == PIN_D7 ||
;;;117            pinConfig.GPIOPin == PIN_F0 ) {
;;;118            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_LOCK_OFFSET) = GPIO_LOCK_KEY;
;;;119        }
;;;120    
;;;121        /* 5. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;122        uint8_t pinAddress = pow(2, pinConfig.GPIOPin % 8);
;;;123        
;;;124        /* 6. Allow changes to selected pin. */
;;;125        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_CR_OFFSET) |= pinAddress;
;;;126    
;;;127        /* 7. Set direction of pin. */
;;;128        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DIR_OFFSET) &= ~pinAddress;
;;;129        if (pinConfig.isOutput)
;;;130            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DIR_OFFSET) |= pinAddress;
;;;131    
;;;132        /* 8. Set alternative function if required. */
;;;133        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AFSEL_OFFSET) &= ~pinAddress;
;;;134        if (pinConfig.isAlternative) {
;;;135            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AFSEL_OFFSET) |= pinAddress;
;;;136            uint32_t mask = 0xFFFFFFFF;
;;;137            mask &= ~(0xF << ((pinConfig.GPIOPin % 8) * 4));
;;;138            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PCTL_OFFSET) &= mask;
;;;139            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PCTL_OFFSET) |=
;;;140                (pinConfig.alternateFunction << ((pinConfig.GPIOPin % 8) * 4));
;;;141        }
;;;142    
;;;143        /* 9. Set pin drive strength to 8mA. This step is performed by default. */
;;;144        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DR8R_OFFSET) |= pinAddress;
;;;145    
;;;146        /* 10. Set pullup, pulldown, or open drain. */
;;;147        if (pinConfig.pull == PULL_UP) {
;;;148            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PUR_OFFSET) |= pinAddress;
;;;149        } else if (pinConfig.pull == PULL_DOWN) {
;;;150            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PDR_OFFSET) |= pinAddress;
;;;151        } else if (pinConfig.pull == OPEN_DRAIN) {
;;;152            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ODR_OFFSET) |= pinAddress;
;;;153        }
;;;154    
;;;155        /* 11. Enable as digital or as analog pins. */
;;;156        if (pinConfig.isAnalog) {
;;;157            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AMSEL_OFFSET) |= pinAddress;
;;;158        } else {
;;;159            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DEN_OFFSET) |= pinAddress;
;;;160        }
;;;161    }
00000c  e8bd87fc          POP      {r2-r10,pc}
                  |L3.16|
000010  f89d0000          LDRB     r0,[sp,#0]            ;71
000014  17c1              ASRS     r1,r0,#31             ;71
000016  eb007151          ADD      r1,r0,r1,LSR #29      ;71
00001a  10ca              ASRS     r2,r1,#3              ;71
00001c  2101              MOVS     r1,#1                 ;71
00001e  4091              LSLS     r1,r1,r2              ;71
000020  4a76              LDR      r2,|L3.508|
000022  6812              LDR      r2,[r2,#0]            ;71
000024  4311              ORRS     r1,r1,r2              ;71
000026  4a75              LDR      r2,|L3.508|
000028  6011              STR      r1,[r2,#0]            ;71
00002a  bf00              NOP                            ;75
                  |L3.44|
00002c  f89d0000          LDRB     r0,[sp,#0]            ;75
000030  17c1              ASRS     r1,r0,#31             ;75
000032  eb007151          ADD      r1,r0,r1,LSR #29      ;75
000036  10ca              ASRS     r2,r1,#3              ;75
000038  2101              MOVS     r1,#1                 ;75
00003a  4091              LSLS     r1,r1,r2              ;75
00003c  4a70              LDR      r2,|L3.512|
00003e  6812              LDR      r2,[r2,#0]            ;75
000040  4011              ANDS     r1,r1,r2              ;75
000042  2900              CMP      r1,#0                 ;75
000044  d0f2              BEQ      |L3.44|
000046  f89d0000          LDRB     r0,[sp,#0]            ;107
00004a  2820              CMP      r0,#0x20              ;107
00004c  db01              BLT      |L3.82|
00004e  2101              MOVS     r1,#1                 ;107
000050  e000              B        |L3.84|
                  |L3.82|
000052  2100              MOVS     r1,#0                 ;107
                  |L3.84|
000054  eba01041          SUB      r0,r0,r1,LSL #5       ;107
000058  10c0              ASRS     r0,r0,#3              ;107
00005a  0300              LSLS     r0,r0,#12             ;107
00005c  f89d1000          LDRB     r1,[sp,#0]            ;107
000060  2920              CMP      r1,#0x20              ;107
000062  db01              BLT      |L3.104|
000064  2101              MOVS     r1,#1                 ;107
000066  e000              B        |L3.106|
                  |L3.104|
000068  2100              MOVS     r1,#0                 ;107
                  |L3.106|
00006a  eb004441          ADD      r4,r0,r1,LSL #17      ;107
00006e  f89d0000          LDRB     r0,[sp,#0]            ;112
000072  2810              CMP      r0,#0x10              ;112
000074  d013              BEQ      |L3.158|
000076  f89d0000          LDRB     r0,[sp,#0]            ;113
00007a  2811              CMP      r0,#0x11              ;113
00007c  d00f              BEQ      |L3.158|
00007e  f89d0000          LDRB     r0,[sp,#0]            ;114
000082  2812              CMP      r0,#0x12              ;114
000084  d00b              BEQ      |L3.158|
000086  f89d0000          LDRB     r0,[sp,#0]            ;115
00008a  2813              CMP      r0,#0x13              ;115
00008c  d007              BEQ      |L3.158|
00008e  f89d0000          LDRB     r0,[sp,#0]            ;116
000092  281f              CMP      r0,#0x1f              ;116
000094  d003              BEQ      |L3.158|
000096  f89d0000          LDRB     r0,[sp,#0]            ;117
00009a  2828              CMP      r0,#0x28              ;117
00009c  d102              BNE      |L3.164|
                  |L3.158|
00009e  4959              LDR      r1,|L3.516|
0000a0  4859              LDR      r0,|L3.520|
0000a2  5101              STR      r1,[r0,r4]            ;118
                  |L3.164|
0000a4  f89da000          LDRB     r10,[sp,#0]           ;122
0000a8  ea4f71ea          ASR      r1,r10,#31            ;122
0000ac  eb0a7151          ADD      r1,r10,r1,LSR #29     ;122
0000b0  10c9              ASRS     r1,r1,#3              ;122
0000b2  ebaa00c1          SUB      r0,r10,r1,LSL #3      ;122
0000b6  f7fffffe          BL       __aeabi_i2d
0000ba  4607              MOV      r7,r0                 ;122
0000bc  463a              MOV      r2,r7                 ;122
0000be  460b              MOV      r3,r1                 ;122
0000c0  2000              MOVS     r0,#0                 ;122
0000c2  f04f4180          MOV      r1,#0x40000000        ;122
0000c6  f7fffffe          BL       pow
0000ca  4605              MOV      r5,r0                 ;122
0000cc  f7fffffe          BL       __aeabi_d2uiz
0000d0  f00009ff          AND      r9,r0,#0xff           ;122
0000d4  484c              LDR      r0,|L3.520|
0000d6  1d00              ADDS     r0,r0,#4              ;125
0000d8  5900              LDR      r0,[r0,r4]            ;125
0000da  ea400009          ORR      r0,r0,r9              ;125
0000de  494a              LDR      r1,|L3.520|
0000e0  1d09              ADDS     r1,r1,#4              ;125
0000e2  5108              STR      r0,[r1,r4]            ;125
0000e4  4849              LDR      r0,|L3.524|
0000e6  5900              LDR      r0,[r0,r4]            ;128
0000e8  ea200009          BIC      r0,r0,r9              ;128
0000ec  4947              LDR      r1,|L3.524|
0000ee  5108              STR      r0,[r1,r4]            ;128
0000f0  f89d0002          LDRB     r0,[sp,#2]            ;129
0000f4  b120              CBZ      r0,|L3.256|
0000f6  4608              MOV      r0,r1                 ;130
0000f8  5900              LDR      r0,[r0,r4]            ;130
0000fa  ea400009          ORR      r0,r0,r9              ;130
0000fe  5108              STR      r0,[r1,r4]            ;130
                  |L3.256|
000100  4842              LDR      r0,|L3.524|
000102  3020              ADDS     r0,r0,#0x20           ;133
000104  5900              LDR      r0,[r0,r4]            ;133
000106  ea200009          BIC      r0,r0,r9              ;133
00010a  4940              LDR      r1,|L3.524|
00010c  3120              ADDS     r1,r1,#0x20           ;133
00010e  5108              STR      r0,[r1,r4]            ;133
000110  f89d0003          LDRB     r0,[sp,#3]            ;134
000114  b370              CBZ      r0,|L3.372|
000116  4608              MOV      r0,r1                 ;135
000118  5900              LDR      r0,[r0,r4]            ;135
00011a  ea400009          ORR      r0,r0,r9              ;135
00011e  460a              MOV      r2,r1                 ;135
000120  5110              STR      r0,[r2,r4]            ;135
000122  f04f31ff          MOV      r1,#0xffffffff        ;136
000126  f89d0000          LDRB     r0,[sp,#0]            ;137
00012a  17c2              ASRS     r2,r0,#31             ;137
00012c  eb007252          ADD      r2,r0,r2,LSR #29      ;137
000130  10d2              ASRS     r2,r2,#3              ;137
000132  eba002c2          SUB      r2,r0,r2,LSL #3       ;137
000136  0093              LSLS     r3,r2,#2              ;137
000138  220f              MOVS     r2,#0xf               ;137
00013a  409a              LSLS     r2,r2,r3              ;137
00013c  4391              BICS     r1,r1,r2              ;137
00013e  4832              LDR      r0,|L3.520|
000140  300c              ADDS     r0,r0,#0xc            ;138
000142  5900              LDR      r0,[r0,r4]            ;138
000144  4008              ANDS     r0,r0,r1              ;138
000146  4a30              LDR      r2,|L3.520|
000148  320c              ADDS     r2,r2,#0xc            ;138
00014a  5110              STR      r0,[r2,r4]            ;138
00014c  f89d0000          LDRB     r0,[sp,#0]            ;139
000150  17c2              ASRS     r2,r0,#31             ;139
000152  eb007252          ADD      r2,r0,r2,LSR #29      ;139
000156  10d2              ASRS     r2,r2,#3              ;139
000158  eba002c2          SUB      r2,r0,r2,LSL #3       ;139
00015c  0093              LSLS     r3,r2,#2              ;139
00015e  f89d2004          LDRB     r2,[sp,#4]            ;139
000162  409a              LSLS     r2,r2,r3              ;139
000164  4b28              LDR      r3,|L3.520|
000166  330c              ADDS     r3,r3,#0xc            ;139
000168  591b              LDR      r3,[r3,r4]            ;139
00016a  431a              ORRS     r2,r2,r3              ;139
00016c  4b26              LDR      r3,|L3.520|
00016e  330c              ADDS     r3,r3,#0xc            ;139
000170  511a              STR      r2,[r3,r4]            ;139
000172  bf00              NOP                            ;141
                  |L3.372|
000174  4824              LDR      r0,|L3.520|
000176  3818              SUBS     r0,r0,#0x18           ;144
000178  5900              LDR      r0,[r0,r4]            ;144
00017a  ea400009          ORR      r0,r0,r9              ;144
00017e  4922              LDR      r1,|L3.520|
000180  3918              SUBS     r1,r1,#0x18           ;144
000182  5108              STR      r0,[r1,r4]            ;144
000184  f89d0001          LDRB     r0,[sp,#1]            ;147
000188  b940              CBNZ     r0,|L3.412|
00018a  481f              LDR      r0,|L3.520|
00018c  3810              SUBS     r0,r0,#0x10           ;148
00018e  5900              LDR      r0,[r0,r4]            ;148
000190  ea400009          ORR      r0,r0,r9              ;148
000194  491c              LDR      r1,|L3.520|
000196  3910              SUBS     r1,r1,#0x10           ;148
000198  5108              STR      r0,[r1,r4]            ;148
00019a  e018              B        |L3.462|
                  |L3.412|
00019c  f89d0001          LDRB     r0,[sp,#1]            ;149
0001a0  2801              CMP      r0,#1                 ;149
0001a2  d108              BNE      |L3.438|
0001a4  4818              LDR      r0,|L3.520|
0001a6  380c              SUBS     r0,r0,#0xc            ;150
0001a8  5900              LDR      r0,[r0,r4]            ;150
0001aa  ea400009          ORR      r0,r0,r9              ;150
0001ae  4916              LDR      r1,|L3.520|
0001b0  390c              SUBS     r1,r1,#0xc            ;150
0001b2  5108              STR      r0,[r1,r4]            ;150
0001b4  e00b              B        |L3.462|
                  |L3.438|
0001b6  f89d0001          LDRB     r0,[sp,#1]            ;151
0001ba  2802              CMP      r0,#2                 ;151
0001bc  d107              BNE      |L3.462|
0001be  4812              LDR      r0,|L3.520|
0001c0  3814              SUBS     r0,r0,#0x14           ;152
0001c2  5900              LDR      r0,[r0,r4]            ;152
0001c4  ea400009          ORR      r0,r0,r9              ;152
0001c8  490f              LDR      r1,|L3.520|
0001ca  3914              SUBS     r1,r1,#0x14           ;152
0001cc  5108              STR      r0,[r1,r4]            ;152
                  |L3.462|
0001ce  f89d0005          LDRB     r0,[sp,#5]            ;156
0001d2  b140              CBZ      r0,|L3.486|
0001d4  480c              LDR      r0,|L3.520|
0001d6  3008              ADDS     r0,r0,#8              ;157
0001d8  5900              LDR      r0,[r0,r4]            ;157
0001da  ea400009          ORR      r0,r0,r9              ;157
0001de  490a              LDR      r1,|L3.520|
0001e0  3108              ADDS     r1,r1,#8              ;157
0001e2  5108              STR      r0,[r1,r4]            ;157
0001e4  e007              B        |L3.502|
                  |L3.486|
0001e6  4808              LDR      r0,|L3.520|
0001e8  1f00              SUBS     r0,r0,#4              ;159
0001ea  5900              LDR      r0,[r0,r4]            ;159
0001ec  ea400009          ORR      r0,r0,r9              ;159
0001f0  4905              LDR      r1,|L3.520|
0001f2  1f09              SUBS     r1,r1,#4              ;159
0001f4  5108              STR      r0,[r1,r4]            ;159
                  |L3.502|
0001f6  bf00              NOP      
0001f8  e708              B        |L3.12|
;;;162    
                          ENDP

0001fa  0000              DCW      0x0000
                  |L3.508|
                          DCD      0x400fe608
                  |L3.512|
                          DCD      0x400fea08
                  |L3.516|
                          DCD      0x4c4f434b
                  |L3.520|
                          DCD      0x40004520
                  |L3.524|
                          DCD      0x40004400

                          AREA ||i.GPIOIntInit||, CODE, READONLY, ALIGN=2

                  GPIOIntInit PROC
;;;169     */
;;;170    void GPIOIntInit(GPIOConfig_t pinConfig, GPIOInterruptConfig_t pinIntConfig) {
000000  b40f              PUSH     {r0-r3}
000002  e92d47f0          PUSH     {r4-r10,lr}
;;;171        /* Early return on invalid pin_t value. */
;;;172        if (pinConfig.GPIOPin >= PIN_COUNT) return;
000006  f89d0020          LDRB     r0,[sp,#0x20]
00000a  2830              CMP      r0,#0x30
00000c  db03              BLT      |L4.22|
                  |L4.14|
;;;173    
;;;174        GPIOInit(pinConfig);
;;;175    
;;;176        /** 1. Generate the port offset to find the correct addresses.
;;;177         *    There are a couple components in this line:
;;;178         * 
;;;179         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;180         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;181         *    details.
;;;182         * 
;;;183         *    (((pin - XXX) >> 3) << 12) : 
;;;184         *          Every group of eight pins belongs to the same port, and every
;;;185         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;186         *          in the datasheet). This expression right shifts the pin to mask
;;;187         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;188         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;189         *          GPIO_PORT_BASE to get the port address.
;;;190         * 
;;;191         *          The term `- XXX` is a conditional expanded to the following:
;;;192         * 
;;;193         *                        XXX = ((pin >= PIN_E0) << 5)
;;;194         * 
;;;195         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;196         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;197         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;198         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;199         * 
;;;200         *    + (pin >= PIN_E0) << 17 : 
;;;201         *          Port E and F are special in that they requires an
;;;202         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;203         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;204         */
;;;205        uint32_t portOffset = 
;;;206            (((pinConfig.GPIOPin - ((pinConfig.GPIOPin >= PIN_E0) << 5)) >> 3) << 12) + 
;;;207            ((pinConfig.GPIOPin >= PIN_E0) << 17);
;;;208    
;;;209        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;210        uint8_t pinAddress = pow(2, pinConfig.GPIOPin % 8);
;;;211    
;;;212        /* 3. Enable interrupts if required. */
;;;213        if (pinIntConfig.touchTask != NULL || pinIntConfig.releaseTask != NULL) {
;;;214            /* 4. Set pin as edge sensitive. */
;;;215            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IS_OFFSET) &= ~pinAddress;
;;;216            if (pinIntConfig.touchTask != NULL && pinIntConfig.releaseTask != NULL) {
;;;217                /* 5. Set pin to interrupt on both edges. */
;;;218                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IBE_OFFSET) |= pinAddress;
;;;219            } else {
;;;220                /* 6. Set pin to interrupt as dictated by GPIOIEV. */
;;;221                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IBE_OFFSET) &= ~pinAddress;
;;;222                if (pinIntConfig.touchTask != NULL) {
;;;223                    /* 7. Set pin to interrupt on a rising edge. */
;;;224                    GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IEV_OFFSET) |= pinAddress;
;;;225                } else {
;;;226                    /* 8. Set pin to interrupt on a falling edge. */
;;;227                    GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IEV_OFFSET) &= ~pinAddress;
;;;228                }
;;;229            }
;;;230    
;;;231            /* 9. Clear flag for the pin. */
;;;232            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ICR_OFFSET) |= pinAddress;
;;;233    
;;;234            /* 10. Arm interrupt for pin. */
;;;235            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IM_OFFSET) |= pinAddress;
;;;236    
;;;237            /* 11. Set GPIO interrupt priority. */
;;;238            uint8_t ID = pinConfig.GPIOPin/8;
;;;239            uint32_t mask = 0xFFFFFFFF;
;;;240            uint32_t intVal = pinIntConfig.priority << 5;
;;;241    
;;;242            /* Our magic number is 8 since to shift a hex value one hex position, we do
;;;243            * 4 binary shifts. To do it twice; 8 binary shifts. Our output should
;;;244            * something like this for priority 2: 0xFF00FFFF, 0x00400000. */
;;;245            mask &= ~(0xFF << (interruptSettings[ID].priorityIdx * 8));
;;;246            intVal = intVal << (interruptSettings[ID].priorityIdx * 8);
;;;247            (*interruptSettings[ID].NVIC_PRI_ADDR) = 
;;;248                ((*interruptSettings[ID].NVIC_PRI_ADDR)&mask)|intVal;
;;;249            
;;;250            /* 12. Enable IRQ X in NVIC. */
;;;251            (*interruptSettings[ID].NVIC_EN_ADDR) = 1 << interruptSettings[ID].IRQ;
;;;252    
;;;253        }
;;;254    
;;;255        /* 13. Assign configuration to the internal data structure. */
;;;256        GPIOIntConfig[pinConfig.GPIOPin] = pinIntConfig;
;;;257    }
00000e  e8bd07f0          POP      {r4-r10}
000012  f85dfb14          LDR      pc,[sp],#0x14
                  |L4.22|
000016  e9dd0108          LDRD     r0,r1,[sp,#0x20]      ;174
00001a  f7fffffe          BL       GPIOInit
00001e  f89d0020          LDRB     r0,[sp,#0x20]         ;205
000022  2820              CMP      r0,#0x20              ;205
000024  db01              BLT      |L4.42|
000026  2101              MOVS     r1,#1                 ;205
000028  e000              B        |L4.44|
                  |L4.42|
00002a  2100              MOVS     r1,#0                 ;205
                  |L4.44|
00002c  eba01041          SUB      r0,r0,r1,LSL #5       ;205
000030  10c0              ASRS     r0,r0,#3              ;205
000032  0300              LSLS     r0,r0,#12             ;205
000034  f89d1020          LDRB     r1,[sp,#0x20]         ;205
000038  2920              CMP      r1,#0x20              ;205
00003a  db01              BLT      |L4.64|
00003c  2101              MOVS     r1,#1                 ;205
00003e  e000              B        |L4.66|
                  |L4.64|
000040  2100              MOVS     r1,#0                 ;205
                  |L4.66|
000042  eb004441          ADD      r4,r0,r1,LSL #17      ;205
000046  f89da020          LDRB     r10,[sp,#0x20]        ;210
00004a  ea4f71ea          ASR      r1,r10,#31            ;210
00004e  eb0a7151          ADD      r1,r10,r1,LSR #29     ;210
000052  10c9              ASRS     r1,r1,#3              ;210
000054  ebaa00c1          SUB      r0,r10,r1,LSL #3      ;210
000058  f7fffffe          BL       __aeabi_i2d
00005c  4607              MOV      r7,r0                 ;210
00005e  463a              MOV      r2,r7                 ;210
000060  460b              MOV      r3,r1                 ;210
000062  2000              MOVS     r0,#0                 ;210
000064  f04f4180          MOV      r1,#0x40000000        ;210
000068  f7fffffe          BL       pow
00006c  4605              MOV      r5,r0                 ;210
00006e  f7fffffe          BL       __aeabi_d2uiz
000072  f00009ff          AND      r9,r0,#0xff           ;210
000076  980b              LDR      r0,[sp,#0x2c]         ;213
000078  b910              CBNZ     r0,|L4.128|
00007a  980c              LDR      r0,[sp,#0x30]         ;213
00007c  2800              CMP      r0,#0                 ;213
00007e  d06a              BEQ      |L4.342|
                  |L4.128|
000080  4b3a              LDR      r3,|L4.364|
000082  591b              LDR      r3,[r3,r4]            ;215
000084  ea230309          BIC      r3,r3,r9              ;215
000088  4d38              LDR      r5,|L4.364|
00008a  512b              STR      r3,[r5,r4]            ;215
00008c  9b0b              LDR      r3,[sp,#0x2c]         ;216
00008e  b143              CBZ      r3,|L4.162|
000090  9b0c              LDR      r3,[sp,#0x30]         ;216
000092  b133              CBZ      r3,|L4.162|
000094  1d2b              ADDS     r3,r5,#4              ;218
000096  591b              LDR      r3,[r3,r4]            ;218
000098  ea430309          ORR      r3,r3,r9              ;218
00009c  1d2d              ADDS     r5,r5,#4              ;218
00009e  512b              STR      r3,[r5,r4]            ;218
0000a0  e018              B        |L4.212|
                  |L4.162|
0000a2  4b32              LDR      r3,|L4.364|
0000a4  1d1b              ADDS     r3,r3,#4              ;221
0000a6  591b              LDR      r3,[r3,r4]            ;221
0000a8  ea230309          BIC      r3,r3,r9              ;221
0000ac  4d2f              LDR      r5,|L4.364|
0000ae  1d2d              ADDS     r5,r5,#4              ;221
0000b0  512b              STR      r3,[r5,r4]            ;221
0000b2  9b0b              LDR      r3,[sp,#0x2c]         ;222
0000b4  b133              CBZ      r3,|L4.196|
0000b6  1d2b              ADDS     r3,r5,#4              ;224
0000b8  591b              LDR      r3,[r3,r4]            ;224
0000ba  ea430309          ORR      r3,r3,r9              ;224
0000be  1d2d              ADDS     r5,r5,#4              ;224
0000c0  512b              STR      r3,[r5,r4]            ;224
0000c2  e007              B        |L4.212|
                  |L4.196|
0000c4  4b29              LDR      r3,|L4.364|
0000c6  3308              ADDS     r3,r3,#8              ;227
0000c8  591b              LDR      r3,[r3,r4]            ;227
0000ca  ea230309          BIC      r3,r3,r9              ;227
0000ce  4d27              LDR      r5,|L4.364|
0000d0  3508              ADDS     r5,r5,#8              ;227
0000d2  512b              STR      r3,[r5,r4]            ;227
                  |L4.212|
0000d4  4b25              LDR      r3,|L4.364|
0000d6  3318              ADDS     r3,r3,#0x18           ;232
0000d8  591b              LDR      r3,[r3,r4]            ;232
0000da  ea430309          ORR      r3,r3,r9              ;232
0000de  4d23              LDR      r5,|L4.364|
0000e0  3518              ADDS     r5,r5,#0x18           ;232
0000e2  512b              STR      r3,[r5,r4]            ;232
0000e4  4b21              LDR      r3,|L4.364|
0000e6  330c              ADDS     r3,r3,#0xc            ;235
0000e8  591b              LDR      r3,[r3,r4]            ;235
0000ea  ea430309          ORR      r3,r3,r9              ;235
0000ee  4d1f              LDR      r5,|L4.364|
0000f0  350c              ADDS     r5,r5,#0xc            ;235
0000f2  512b              STR      r3,[r5,r4]            ;235
0000f4  f89d3020          LDRB     r3,[sp,#0x20]         ;238
0000f8  17dd              ASRS     r5,r3,#31             ;238
0000fa  eb037555          ADD      r5,r3,r5,LSR #29      ;238
0000fe  10e8              ASRS     r0,r5,#3              ;238
000100  f04f31ff          MOV      r1,#0xffffffff        ;239
000104  f89d3028          LDRB     r3,[sp,#0x28]         ;240
000108  015a              LSLS     r2,r3,#5              ;240
00010a  4b19              LDR      r3,|L4.368|
00010c  eb031300          ADD      r3,r3,r0,LSL #4       ;245
000110  781b              LDRB     r3,[r3,#0]            ;245
000112  00dd              LSLS     r5,r3,#3              ;245
000114  23ff              MOVS     r3,#0xff              ;245
000116  40ab              LSLS     r3,r3,r5              ;245
000118  4399              BICS     r1,r1,r3              ;245
00011a  4b15              LDR      r3,|L4.368|
00011c  eb031300          ADD      r3,r3,r0,LSL #4       ;246
000120  781b              LDRB     r3,[r3,#0]            ;246
000122  00db              LSLS     r3,r3,#3              ;246
000124  409a              LSLS     r2,r2,r3              ;246
000126  4b12              LDR      r3,|L4.368|
000128  eb031300          ADD      r3,r3,r0,LSL #4       ;247
00012c  685b              LDR      r3,[r3,#4]            ;247
00012e  681b              LDR      r3,[r3,#0]            ;247
000130  400b              ANDS     r3,r3,r1              ;247
000132  4313              ORRS     r3,r3,r2              ;247
000134  4d0e              LDR      r5,|L4.368|
000136  eb051500          ADD      r5,r5,r0,LSL #4       ;247
00013a  686d              LDR      r5,[r5,#4]            ;247
00013c  602b              STR      r3,[r5,#0]            ;247
00013e  4b0c              LDR      r3,|L4.368|
000140  eb031300          ADD      r3,r3,r0,LSL #4       ;251
000144  7b1d              LDRB     r5,[r3,#0xc]          ;251
000146  2301              MOVS     r3,#1                 ;251
000148  40ab              LSLS     r3,r3,r5              ;251
00014a  4d09              LDR      r5,|L4.368|
00014c  eb051500          ADD      r5,r5,r0,LSL #4       ;251
000150  68ad              LDR      r5,[r5,#8]            ;251
000152  602b              STR      r3,[r5,#0]            ;251
000154  bf00              NOP                            ;253
                  |L4.342|
000156  f89d0020          LDRB     r0,[sp,#0x20]         ;256
00015a  4906              LDR      r1,|L4.372|
00015c  eb011000          ADD      r0,r1,r0,LSL #4       ;256
000160  a90a              ADD      r1,sp,#0x28           ;256
000162  c92e              LDM      r1,{r1-r3,r5}         ;256
000164  c02e              STM      r0!,{r1-r3,r5}        ;256
000166  bf00              NOP      
000168  e751              B        |L4.14|
;;;258    
                          ENDP

00016a  0000              DCW      0x0000
                  |L4.364|
                          DCD      0x40004404
                  |L4.368|
                          DCD      interruptSettings
                  |L4.372|
                          DCD      GPIOIntConfig

                          AREA ||i.GPIOPortA_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortA_Handler PROC
;;;329    
;;;330    void GPIOPortA_Handler(void) { GPIOGeneric_Handler(PIN_A0); }
000000  b510              PUSH     {r4,lr}
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;331    
                          ENDP


                          AREA ||i.GPIOPortB_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortB_Handler PROC
;;;331    
;;;332    void GPIOPortB_Handler(void) { GPIOGeneric_Handler(PIN_B0); }
000000  b510              PUSH     {r4,lr}
000002  2008              MOVS     r0,#8
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;333    
                          ENDP


                          AREA ||i.GPIOPortC_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortC_Handler PROC
;;;333    
;;;334    void GPIOPortC_Handler(void) { GPIOGeneric_Handler(PIN_C0); }
000000  b510              PUSH     {r4,lr}
000002  2010              MOVS     r0,#0x10
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;335    
                          ENDP


                          AREA ||i.GPIOPortD_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortD_Handler PROC
;;;335    
;;;336    void GPIOPortD_Handler(void) { GPIOGeneric_Handler(PIN_D0); }
000000  b510              PUSH     {r4,lr}
000002  2018              MOVS     r0,#0x18
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;337    
                          ENDP


                          AREA ||i.GPIOPortE_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortE_Handler PROC
;;;337    
;;;338    void GPIOPortE_Handler(void) { GPIOGeneric_Handler(PIN_E0); }
000000  b510              PUSH     {r4,lr}
000002  2020              MOVS     r0,#0x20
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.GPIOPortF_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortF_Handler PROC
;;;339    
;;;340    void GPIOPortF_Handler(void) { GPIOGeneric_Handler(PIN_F0); }
000000  b510              PUSH     {r4,lr}
000002  2028              MOVS     r0,#0x28
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;341    
                          ENDP


                          AREA ||i.GPIOSetBit||, CODE, READONLY, ALIGN=1

                  GPIOSetBit PROC
;;;638     */
;;;639    bool GPIOSetBit(pin_t pin, bool value) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
;;;640        /* Early return on invalid pin_t value. */
;;;641        if (pin >= PIN_COUNT) return false;
000004  2a30              CMP      r2,#0x30
000006  db01              BLT      |L11.12|
000008  2000              MOVS     r0,#0
                  |L11.10|
;;;642    
;;;643        /** 1. Generate the port offset to find the correct addresses.
;;;644         *    There are a couple components in this line:
;;;645         * 
;;;646         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;647         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;648         *    details.
;;;649         * 
;;;650         *    (((pin - XXX) >> 3) << 12) : 
;;;651         *          Every group of eight pins belongs to the same port, and every
;;;652         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;653         *          in the datasheet). This expression right shifts the pin to mask
;;;654         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;655         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;656         *          GPIO_PORT_BASE to get the port address.
;;;657         * 
;;;658         *          The term `- XXX` is a conditional expanded to the following:
;;;659         * 
;;;660         *                        XXX = ((pin >= PIN_E0) << 5)
;;;661         * 
;;;662         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;663         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;664         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;665         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;666         * 
;;;667         *    + (pin >= PIN_E0) << 17 : 
;;;668         *          Port E and F are special in that they requires an
;;;669         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;670         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;671         */
;;;672        uint32_t portOffset = 
;;;673            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;674    
;;;675        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;676        pin &= 0x07;
;;;677        GET_REG(GPIO_PORT_BASE + portOffset + (1 << (pin + 2))) = value << pin;
;;;678        return true;
;;;679    }
00000a  bd70              POP      {r4-r6,pc}
                  |L11.12|
00000c  2a20              CMP      r2,#0x20              ;672
00000e  db01              BLT      |L11.20|
000010  2001              MOVS     r0,#1                 ;672
000012  e000              B        |L11.22|
                  |L11.20|
000014  2000              MOVS     r0,#0                 ;672
                  |L11.22|
000016  eba21040          SUB      r0,r2,r0,LSL #5       ;672
00001a  10c0              ASRS     r0,r0,#3              ;672
00001c  0300              LSLS     r0,r0,#12             ;672
00001e  2a20              CMP      r2,#0x20              ;672
000020  db01              BLT      |L11.38|
000022  2401              MOVS     r4,#1                 ;672
000024  e000              B        |L11.40|
                  |L11.38|
000026  2400              MOVS     r4,#0                 ;672
                  |L11.40|
000028  eb004344          ADD      r3,r0,r4,LSL #17      ;672
00002c  f0020207          AND      r2,r2,#7              ;676
000030  fa01f002          LSL      r0,r1,r2              ;677
000034  f1032440          ADD      r4,r3,#0x40004000     ;677
000038  1c95              ADDS     r5,r2,#2              ;677
00003a  2601              MOVS     r6,#1                 ;677
00003c  40ae              LSLS     r6,r6,r5              ;677
00003e  51a0              STR      r0,[r4,r6]            ;677
000040  2001              MOVS     r0,#1                 ;678
000042  e7e2              B        |L11.10|
;;;680    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GPIOIntConfig
                          %        768

                          AREA ||.data||, DATA, ALIGN=2

                  interruptSettings
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000000
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000001
000020  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000002
000030  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000003
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e404
                          DCD      0xe000e100
                          DCD      0x00000004
000050  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e41c
                          DCD      0xe000e100
                          DCD      0x0000001e
