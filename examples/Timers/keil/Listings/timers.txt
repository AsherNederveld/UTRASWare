; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\timers.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timers.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I.. -I..\..\.. -I.\RTE\_Timers -IC:\Users\matth\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\matth\AppData\Local\Arm\Packs\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -D__MICROLIB -D__UVISION_VERSION=533 -D_RTE_ -DTM4C123GH6PM -D_RTE_ -Drvmdk -DPART_LM4F120H5QR --omf_browse=.\objects\timers.crf ..\..\..\lib\Timers\Timers.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;379    
;;;380    void SysTick_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;381        ++tick;
000002  4809              LDR      r0,|L1.40|
000004  e9d02000          LDRD     r2,r0,[r0,#0]
000008  1c52              ADDS     r2,r2,#1
00000a  f1400000          ADC      r0,r0,#0
00000e  4906              LDR      r1,|L1.40|
000010  e9c12000          STRD     r2,r0,[r1,#0]
;;;382    
;;;383        if (interruptSettings[24].timerHandlerTask != NULL) {
000014  4805              LDR      r0,|L1.44|
000016  f8d001f0          LDR      r0,[r0,#0x1f0]
00001a  b118              CBZ      r0,|L1.36|
;;;384            interruptSettings[24].timerHandlerTask();
00001c  4903              LDR      r1,|L1.44|
00001e  f8d101f0          LDR      r0,[r1,#0x1f0]
000022  4780              BLX      r0
                  |L1.36|
;;;385        }
;;;386    }
000024  bd10              POP      {r4,pc}
;;;387    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      tick
                  |L1.44|
                          DCD      interruptSettings

                          AREA ||i.Timer0A_Handler||, CODE, READONLY, ALIGN=2

                  Timer0A_Handler PROC
;;;279    
;;;280    void Timer0A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;281        GET_REG(GPTM_BASE + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4806              LDR      r0,|L2.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4904              LDR      r1,|L2.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;282        if (interruptSettings[0].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L2.32|
000010  6900              LDR      r0,[r0,#0x10]  ; interruptSettings
000012  b110              CBZ      r0,|L2.26|
;;;283            interruptSettings[0].timerHandlerTask();
000014  4902              LDR      r1,|L2.32|
000016  6908              LDR      r0,[r1,#0x10]  ; interruptSettings
000018  4780              BLX      r0
                  |L2.26|
;;;284        }
;;;285    }
00001a  bd10              POP      {r4,pc}
;;;286    
                          ENDP

                  |L2.28|
                          DCD      0x40030000
                  |L2.32|
                          DCD      interruptSettings

                          AREA ||i.Timer0B_Handler||, CODE, READONLY, ALIGN=2

                  Timer0B_Handler PROC
;;;286    
;;;287    void Timer0B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;288        GET_REG(GPTM_BASE + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4806              LDR      r0,|L3.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4904              LDR      r1,|L3.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;289        if (interruptSettings[1].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L3.32|
000010  6a40              LDR      r0,[r0,#0x24]
000012  b110              CBZ      r0,|L3.26|
;;;290            interruptSettings[1].timerHandlerTask();
000014  4902              LDR      r1,|L3.32|
000016  6a48              LDR      r0,[r1,#0x24]
000018  4780              BLX      r0
                  |L3.26|
;;;291        }
;;;292    }
00001a  bd10              POP      {r4,pc}
;;;293    
                          ENDP

                  |L3.28|
                          DCD      0x40030000
                  |L3.32|
                          DCD      interruptSettings

                          AREA ||i.Timer1A_Handler||, CODE, READONLY, ALIGN=2

                  Timer1A_Handler PROC
;;;293    
;;;294    void Timer1A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;295        GET_REG(GPTM_BASE + 0x1000 + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4806              LDR      r0,|L4.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4904              LDR      r1,|L4.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;296        if (interruptSettings[2].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L4.32|
000010  6b80              LDR      r0,[r0,#0x38]
000012  b110              CBZ      r0,|L4.26|
;;;297            interruptSettings[2].timerHandlerTask();
000014  4902              LDR      r1,|L4.32|
000016  6b88              LDR      r0,[r1,#0x38]
000018  4780              BLX      r0
                  |L4.26|
;;;298        }
;;;299    }
00001a  bd10              POP      {r4,pc}
;;;300    
                          ENDP

                  |L4.28|
                          DCD      0x40031000
                  |L4.32|
                          DCD      interruptSettings

                          AREA ||i.Timer1B_Handler||, CODE, READONLY, ALIGN=2

                  Timer1B_Handler PROC
;;;300    
;;;301    void Timer1B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;302        GET_REG(GPTM_BASE + 0x1000 + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4806              LDR      r0,|L5.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4904              LDR      r1,|L5.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;303        if (interruptSettings[3].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L5.32|
000010  6cc0              LDR      r0,[r0,#0x4c]
000012  b110              CBZ      r0,|L5.26|
;;;304            interruptSettings[3].timerHandlerTask();
000014  4902              LDR      r1,|L5.32|
000016  6cc8              LDR      r0,[r1,#0x4c]
000018  4780              BLX      r0
                  |L5.26|
;;;305        }
;;;306    }
00001a  bd10              POP      {r4,pc}
;;;307    
                          ENDP

                  |L5.28|
                          DCD      0x40031000
                  |L5.32|
                          DCD      interruptSettings

                          AREA ||i.Timer2A_Handler||, CODE, READONLY, ALIGN=2

                  Timer2A_Handler PROC
;;;307    
;;;308    void Timer2A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;309        GET_REG(GPTM_BASE + 0x2000 + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4806              LDR      r0,|L6.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4904              LDR      r1,|L6.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;310        if (interruptSettings[4].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L6.32|
000010  6e00              LDR      r0,[r0,#0x60]
000012  b110              CBZ      r0,|L6.26|
;;;311            interruptSettings[4].timerHandlerTask();
000014  4902              LDR      r1,|L6.32|
000016  6e08              LDR      r0,[r1,#0x60]
000018  4780              BLX      r0
                  |L6.26|
;;;312        }
;;;313    }
00001a  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  |L6.28|
                          DCD      0x40032000
                  |L6.32|
                          DCD      interruptSettings

                          AREA ||i.Timer2B_Handler||, CODE, READONLY, ALIGN=2

                  Timer2B_Handler PROC
;;;314    
;;;315    void Timer2B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;316        GET_REG(GPTM_BASE + 0x2000 + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4806              LDR      r0,|L7.28|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4904              LDR      r1,|L7.28|
00000c  6248              STR      r0,[r1,#0x24]
;;;317        if (interruptSettings[5].timerHandlerTask != NULL) {
00000e  4804              LDR      r0,|L7.32|
000010  6f40              LDR      r0,[r0,#0x74]
000012  b110              CBZ      r0,|L7.26|
;;;318            interruptSettings[5].timerHandlerTask();
000014  4902              LDR      r1,|L7.32|
000016  6f48              LDR      r0,[r1,#0x74]
000018  4780              BLX      r0
                  |L7.26|
;;;319        }
;;;320    }
00001a  bd10              POP      {r4,pc}
;;;321    
                          ENDP

                  |L7.28|
                          DCD      0x40032000
                  |L7.32|
                          DCD      interruptSettings

                          AREA ||i.Timer3A_Handler||, CODE, READONLY, ALIGN=2

                  Timer3A_Handler PROC
;;;321    
;;;322    void Timer3A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;323        GET_REG(GPTM_BASE + 0x3000 + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4807              LDR      r0,|L8.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4905              LDR      r1,|L8.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;324        if (interruptSettings[6].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L8.36|
000010  f8d00088          LDR      r0,[r0,#0x88]
000014  b118              CBZ      r0,|L8.30|
;;;325            interruptSettings[6].timerHandlerTask();
000016  4903              LDR      r1,|L8.36|
000018  f8d10088          LDR      r0,[r1,#0x88]
00001c  4780              BLX      r0
                  |L8.30|
;;;326        }
;;;327    }
00001e  bd10              POP      {r4,pc}
;;;328    
                          ENDP

                  |L8.32|
                          DCD      0x40033000
                  |L8.36|
                          DCD      interruptSettings

                          AREA ||i.Timer3B_Handler||, CODE, READONLY, ALIGN=2

                  Timer3B_Handler PROC
;;;328    
;;;329    void Timer3B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;330        GET_REG(GPTM_BASE + 0x3000 + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4807              LDR      r0,|L9.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4905              LDR      r1,|L9.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;331        if (interruptSettings[7].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L9.36|
000010  f8d0009c          LDR      r0,[r0,#0x9c]
000014  b118              CBZ      r0,|L9.30|
;;;332            interruptSettings[7].timerHandlerTask();
000016  4903              LDR      r1,|L9.36|
000018  f8d1009c          LDR      r0,[r1,#0x9c]
00001c  4780              BLX      r0
                  |L9.30|
;;;333        }
;;;334    }
00001e  bd10              POP      {r4,pc}
;;;335    
                          ENDP

                  |L9.32|
                          DCD      0x40033000
                  |L9.36|
                          DCD      interruptSettings

                          AREA ||i.Timer4A_Handler||, CODE, READONLY, ALIGN=2

                  Timer4A_Handler PROC
;;;335    
;;;336    void Timer4A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;337        GET_REG(GPTM_BASE + 0x4000 + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4807              LDR      r0,|L10.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4905              LDR      r1,|L10.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;338        if (interruptSettings[8].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L10.36|
000010  f8d000b0          LDR      r0,[r0,#0xb0]
000014  b118              CBZ      r0,|L10.30|
;;;339            interruptSettings[8].timerHandlerTask();
000016  4903              LDR      r1,|L10.36|
000018  f8d100b0          LDR      r0,[r1,#0xb0]
00001c  4780              BLX      r0
                  |L10.30|
;;;340        }
;;;341    }
00001e  bd10              POP      {r4,pc}
;;;342    
                          ENDP

                  |L10.32|
                          DCD      0x40034000
                  |L10.36|
                          DCD      interruptSettings

                          AREA ||i.Timer4B_Handler||, CODE, READONLY, ALIGN=2

                  Timer4B_Handler PROC
;;;342    
;;;343    void Timer4B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;344        GET_REG(GPTM_BASE + 0x4000 + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4807              LDR      r0,|L11.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4905              LDR      r1,|L11.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;345        if (interruptSettings[9].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L11.36|
000010  f8d000c4          LDR      r0,[r0,#0xc4]
000014  b118              CBZ      r0,|L11.30|
;;;346            interruptSettings[9].timerHandlerTask();
000016  4903              LDR      r1,|L11.36|
000018  f8d100c4          LDR      r0,[r1,#0xc4]
00001c  4780              BLX      r0
                  |L11.30|
;;;347        }
;;;348    }
00001e  bd10              POP      {r4,pc}
;;;349    
                          ENDP

                  |L11.32|
                          DCD      0x40034000
                  |L11.36|
                          DCD      interruptSettings

                          AREA ||i.Timer5A_Handler||, CODE, READONLY, ALIGN=2

                  Timer5A_Handler PROC
;;;349    
;;;350    void Timer5A_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;351        GET_REG(GPTM_BASE + 0x5000 + GPTMICR_OFFSET) |= TIMERXA_ICR_TATOCINT;
000002  4807              LDR      r0,|L12.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f0400001          ORR      r0,r0,#1
00000a  4905              LDR      r1,|L12.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;352        if (interruptSettings[10].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L12.36|
000010  f8d000d8          LDR      r0,[r0,#0xd8]
000014  b118              CBZ      r0,|L12.30|
;;;353            interruptSettings[10].timerHandlerTask();
000016  4903              LDR      r1,|L12.36|
000018  f8d100d8          LDR      r0,[r1,#0xd8]
00001c  4780              BLX      r0
                  |L12.30|
;;;354        }
;;;355    }
00001e  bd10              POP      {r4,pc}
;;;356    
                          ENDP

                  |L12.32|
                          DCD      0x40035000
                  |L12.36|
                          DCD      interruptSettings

                          AREA ||i.Timer5B_Handler||, CODE, READONLY, ALIGN=2

                  Timer5B_Handler PROC
;;;356    
;;;357    void Timer5B_Handler(void) {
000000  b510              PUSH     {r4,lr}
;;;358        GET_REG(GPTM_BASE + 0x5000 + GPTMICR_OFFSET) |= TIMERXB_ICR_TATOCINT;
000002  4807              LDR      r0,|L13.32|
000004  6a40              LDR      r0,[r0,#0x24]
000006  f4407080          ORR      r0,r0,#0x100
00000a  4905              LDR      r1,|L13.32|
00000c  6248              STR      r0,[r1,#0x24]
;;;359        if (interruptSettings[11].timerHandlerTask != NULL) {
00000e  4805              LDR      r0,|L13.36|
000010  f8d000ec          LDR      r0,[r0,#0xec]
000014  b118              CBZ      r0,|L13.30|
;;;360            interruptSettings[11].timerHandlerTask();
000016  4903              LDR      r1,|L13.36|
000018  f8d100ec          LDR      r0,[r1,#0xec]
00001c  4780              BLX      r0
                  |L13.30|
;;;361        }
;;;362    }
00001e  bd10              POP      {r4,pc}
;;;363    
                          ENDP

                  |L13.32|
                          DCD      0x40035000
                  |L13.36|
                          DCD      interruptSettings

                          AREA ||i.TimerInit||, CODE, READONLY, ALIGN=2

                  TimerInit PROC
;;;87      */
;;;88     void TimerInit(TimerConfig_t timerConfig) {
000000  b57f              PUSH     {r0-r6,lr}
;;;89         uint8_t ID = timerConfig.timerID;
000002  f89d0000          LDRB     r0,[sp,#0]
;;;90     
;;;91         /* Early return on invalid timer enum or invalid priority. */
;;;92         if (ID == TIMER_COUNT || timerConfig.priority > 0x7) return;
000006  2819              CMP      r0,#0x19
000008  d003              BEQ      |L14.18|
00000a  f89d4009          LDRB     r4,[sp,#9]
00000e  2c07              CMP      r4,#7
000010  dd00              BLE      |L14.20|
                  |L14.18|
;;;93     
;;;94         /* Assign the task to the appropriate handler. */
;;;95         interruptSettings[ID].timerHandlerTask = timerConfig.handlerTask;
;;;96         
;;;97         /* Special case for SYSTICK. */
;;;98         if (ID == SYSTICK) {    
;;;99             /* Disable during setup. */
;;;100            GET_REG(PERIPHERALS_BASE + SYSTICK_CTRL_OFFSET) = 0x00000000;
;;;101    
;;;102            /* Set reload value. */
;;;103            GET_REG(PERIPHERALS_BASE + SYSTICK_LOAD_OFFSET) = timerConfig.period - 1;
;;;104    
;;;105            /* Clear current value. */
;;;106            GET_REG(PERIPHERALS_BASE + SYSTICK_CURR_OFFSET) = 0x00000000;
;;;107    
;;;108            /* Set priority. */
;;;109            GET_REG(PERIPHERALS_BASE + SYS_PRI3_OFFSET) &= 0x00FFFFFF;
;;;110            GET_REG(PERIPHERALS_BASE + SYS_PRI3_OFFSET) |= timerConfig.priority << 29;
;;;111    
;;;112            /* Re-enable after setup. */
;;;113            GET_REG(PERIPHERALS_BASE + SYSTICK_CTRL_OFFSET) = 0x00000007;
;;;114            return;
;;;115        }
;;;116    
;;;117        /* We'll generate the timer offset to find the correct addresses for each
;;;118         * timer. */
;;;119        uint32_t timerOffset = 0;
;;;120    
;;;121        /* Timers TIMER_0A to WTIMER_1B. */
;;;122        if (ID < WTIMER_2A) timerOffset = 0x1000 * (uint32_t)(ID >> 1);
;;;123    
;;;124        /* Timers WTIMER_2A to WTIMER_5B. Jump the base to 0x4004.C000. Our magic
;;;125         * number, 16, is the enumerated value of WTIMER_2A. */
;;;126        else timerOffset = 0x1000 * (uint32_t)((ID-16) >> 1) + 0x0001C000;
;;;127    
;;;128        /* Step 1. Activate the timer and stall until ready. */
;;;129        if (ID <= TIMER_5B) { /* 16/32 bit normal timers. */
;;;130            GET_REG(SYSCTL_BASE + SYSCTL_RCGCTIMER_OFFSET) |= (0x01 << (uint32_t)(ID >> 1));
;;;131            while ((GET_REG(SYSCTL_BASE + SYSCTL_PRTIMER_OFFSET) & 
;;;132                (0x01 << (uint32_t)(ID >> 1))) == 0) {};
;;;133        } else { /* 32/64 bit wide timers. */
;;;134            /* Our magic number 12, is the enumerated value of WTIMER_0A. */
;;;135            GET_REG(SYSCTL_BASE + SYSCTL_RCGCWTIMER_OFFSET) |= (0x01 << (uint32_t)((ID-12) >> 1)); 
;;;136            while ((GET_REG(SYSCTL_BASE + SYSCTL_PRWTIMER_OFFSET) & 
;;;137                (0x01 << (uint32_t)((ID-12) >> 1))) == 0) {};
;;;138        }
;;;139    
;;;140            
;;;141        /* Step 2. Disable timer during setup. */
;;;142        GET_REG(GPTM_BASE + timerOffset + GPTMCTL_OFFSET) &=
;;;143            ((ID % 2) == 0) ? 0xFFFFFF00 : 0xFFFFFF00FF;
;;;144    
;;;145        /* Step 3. Configure for 32-bit mode. */
;;;146        GET_REG(GPTM_BASE + timerOffset + GPTMCFG_OFFSET) = 0x00000000;
;;;147    
;;;148        /* Step 4. Configure for periodic mode.
;;;149         * Step 5. Set reload value.
;;;150         * Step 6. Set prescaler to 1. */
;;;151        if ((ID % 2) == 0) { /* Timer A. */
;;;152            GET_REG(GPTM_BASE + timerOffset + GPTMTAMR_OFFSET)  = 
;;;153                timerConfig.isPeriodic ? 0x00000002 : 0x00000001;
;;;154            GET_REG(GPTM_BASE + timerOffset + GPTMTAILR_OFFSET) = timerConfig.period - 1;
;;;155            GET_REG(GPTM_BASE + timerOffset + GPTMTAPR_OFFSET)  = 0x00000000;
;;;156        } else { /* Timer B. */
;;;157            GET_REG(GPTM_BASE + timerOffset + GPTMTBMR_OFFSET)  =
;;;158                timerConfig.isPeriodic ? 0x00000002 : 0x00000001;
;;;159            GET_REG(GPTM_BASE + timerOffset + GPTMTBILR_OFFSET) = timerConfig.period - 1;
;;;160            GET_REG(GPTM_BASE + timerOffset + GPTMTBPR_OFFSET)  = 0x00000000;
;;;161        }
;;;162    
;;;163        /* Step 7. Clear timer timeout flag. */
;;;164        GET_REG(GPTM_BASE + timerOffset + GPTMICR_OFFSET) |=
;;;165            ((ID % 2) == 0) ? TIMERXA_ICR_TATOCINT: TIMERXB_ICR_TATOCINT;
;;;166    
;;;167        /* Step 8. Arm timeout interrupt. */
;;;168        GET_REG(GPTM_BASE + timerOffset + GPTMIMR_OFFSET) |=
;;;169            ((ID % 2) == 0) ? 0x00000001 : 0x00000100;
;;;170    
;;;171        /* Step 9. Set timer interrupt priority. */
;;;172        uint32_t mask = 0xFFFFFFFF;
;;;173        uint32_t intVal = timerConfig.priority << 5;
;;;174    
;;;175        /* Our magic number is 8 since to shift a hex value one hex position, we do
;;;176         * 4 binary shifts. To do it twice; 8 binary shifts. Our output should
;;;177         * something like this for priority 2: 0xFF00FFFF, 0x00400000. */
;;;178        mask &= ~(0xFF << (interruptSettings[ID].priorityIdx * 8));
;;;179        intVal = intVal << (interruptSettings[ID].priorityIdx * 8);
;;;180        (*interruptSettings[ID].NVIC_PRI_ADDR) = 
;;;181            ((*interruptSettings[ID].NVIC_PRI_ADDR)&mask)|intVal;
;;;182        
;;;183        /* Step 10. Enable IRQ X in NVIC. */
;;;184        (*interruptSettings[ID].NVIC_EN_ADDR) = 1 << interruptSettings[ID].IRQ;
;;;185    
;;;186        /* Step 11. Enable timer after setup. */
;;;187        GET_REG(GPTM_BASE + timerOffset + GPTMCTL_OFFSET) |=
;;;188            ((ID % 2) == 0) ? 0x00000001 : 0x00000100;
;;;189    }
000012  bd7f              POP      {r0-r6,pc}
                  |L14.20|
000014  eb000580          ADD      r5,r0,r0,LSL #2       ;95
000018  4e83              LDR      r6,|L14.552|
00001a  eb060585          ADD      r5,r6,r5,LSL #2       ;95
00001e  9c03              LDR      r4,[sp,#0xc]          ;95
000020  612c              STR      r4,[r5,#0x10]         ;95
000022  2818              CMP      r0,#0x18              ;98
000024  d11b              BNE      |L14.94|
000026  2400              MOVS     r4,#0                 ;100
000028  f04f25e0          MOV      r5,#0xe000e000        ;100
00002c  612c              STR      r4,[r5,#0x10]         ;100
00002e  9c01              LDR      r4,[sp,#4]            ;103
000030  1e64              SUBS     r4,r4,#1              ;103
000032  616c              STR      r4,[r5,#0x14]         ;103
000034  2400              MOVS     r4,#0                 ;106
000036  61ac              STR      r4,[r5,#0x18]         ;106
000038  4c7c              LDR      r4,|L14.556|
00003a  6824              LDR      r4,[r4,#0]            ;109
00003c  f024447f          BIC      r4,r4,#0xff000000     ;109
000040  4d7a              LDR      r5,|L14.556|
000042  602c              STR      r4,[r5,#0]            ;109
000044  462c              MOV      r4,r5                 ;110
000046  6824              LDR      r4,[r4,#0]            ;110
000048  f89d5009          LDRB     r5,[sp,#9]            ;110
00004c  ea447445          ORR      r4,r4,r5,LSL #29      ;110
000050  4d76              LDR      r5,|L14.556|
000052  602c              STR      r4,[r5,#0]            ;110
000054  2407              MOVS     r4,#7                 ;113
000056  f04f25e0          MOV      r5,#0xe000e000        ;113
00005a  612c              STR      r4,[r5,#0x10]         ;113
00005c  e7d9              B        |L14.18|
                  |L14.94|
00005e  2100              MOVS     r1,#0                 ;119
000060  2810              CMP      r0,#0x10              ;122
000062  da02              BGE      |L14.106|
000064  1044              ASRS     r4,r0,#1              ;122
000066  0321              LSLS     r1,r4,#12             ;122
000068  e005              B        |L14.118|
                  |L14.106|
00006a  f1a00410          SUB      r4,r0,#0x10           ;126
00006e  1064              ASRS     r4,r4,#1              ;126
000070  0324              LSLS     r4,r4,#12             ;126
000072  f50431e0          ADD      r1,r4,#0x1c000        ;126
                  |L14.118|
000076  280b              CMP      r0,#0xb               ;129
000078  dc11              BGT      |L14.158|
00007a  4c6d              LDR      r4,|L14.560|
00007c  6824              LDR      r4,[r4,#0]            ;130
00007e  1046              ASRS     r6,r0,#1              ;130
000080  2501              MOVS     r5,#1                 ;130
000082  40b5              LSLS     r5,r5,r6              ;130
000084  432c              ORRS     r4,r4,r5              ;130
000086  4d6a              LDR      r5,|L14.560|
000088  602c              STR      r4,[r5,#0]            ;130
00008a  bf00              NOP                            ;131
                  |L14.140|
00008c  4c69              LDR      r4,|L14.564|
00008e  6824              LDR      r4,[r4,#0]            ;131
000090  1046              ASRS     r6,r0,#1              ;131
000092  2501              MOVS     r5,#1                 ;131
000094  40b5              LSLS     r5,r5,r6              ;131
000096  402c              ANDS     r4,r4,r5              ;131
000098  2c00              CMP      r4,#0                 ;131
00009a  d0f7              BEQ      |L14.140|
00009c  e017              B        |L14.206|
                  |L14.158|
00009e  4c64              LDR      r4,|L14.560|
0000a0  3458              ADDS     r4,r4,#0x58           ;135
0000a2  6824              LDR      r4,[r4,#0]            ;135
0000a4  f1a0050c          SUB      r5,r0,#0xc            ;135
0000a8  106e              ASRS     r6,r5,#1              ;135
0000aa  2501              MOVS     r5,#1                 ;135
0000ac  40b5              LSLS     r5,r5,r6              ;135
0000ae  432c              ORRS     r4,r4,r5              ;135
0000b0  4d5f              LDR      r5,|L14.560|
0000b2  3558              ADDS     r5,r5,#0x58           ;135
0000b4  602c              STR      r4,[r5,#0]            ;135
0000b6  bf00              NOP                            ;136
                  |L14.184|
0000b8  4c5e              LDR      r4,|L14.564|
0000ba  3458              ADDS     r4,r4,#0x58           ;136
0000bc  6824              LDR      r4,[r4,#0]            ;136
0000be  f1a0050c          SUB      r5,r0,#0xc            ;136
0000c2  106e              ASRS     r6,r5,#1              ;136
0000c4  2501              MOVS     r5,#1                 ;136
0000c6  40b5              LSLS     r5,r5,r6              ;136
0000c8  402c              ANDS     r4,r4,r5              ;136
0000ca  2c00              CMP      r4,#0                 ;136
0000cc  d0f4              BEQ      |L14.184|
                  |L14.206|
0000ce  4604              MOV      r4,r0                 ;142
0000d0  eb0075d4          ADD      r5,r0,r4,LSR #31      ;142
0000d4  106d              ASRS     r5,r5,#1              ;142
0000d6  eba00545          SUB      r5,r0,r5,LSL #1       ;142
0000da  b915              CBNZ     r5,|L14.226|
0000dc  f06f05ff          MVN      r5,#0xff              ;143
0000e0  e001              B        |L14.230|
                  |L14.226|
0000e2  f46f457f          MVN      r5,#0xff00            ;143
                  |L14.230|
0000e6  4e54              LDR      r6,|L14.568|
0000e8  440e              ADD      r6,r6,r1              ;143
0000ea  68f6              LDR      r6,[r6,#0xc]          ;143
0000ec  4035              ANDS     r5,r5,r6              ;143
0000ee  4e52              LDR      r6,|L14.568|
0000f0  440e              ADD      r6,r6,r1              ;143
0000f2  60f5              STR      r5,[r6,#0xc]          ;143
0000f4  2400              MOVS     r4,#0                 ;146
0000f6  4d50              LDR      r5,|L14.568|
0000f8  514c              STR      r4,[r1,r5]            ;146
0000fa  4604              MOV      r4,r0                 ;151
0000fc  eb0075d4          ADD      r5,r0,r4,LSR #31      ;151
000100  106d              ASRS     r5,r5,#1              ;151
000102  eba00545          SUB      r5,r0,r5,LSL #1       ;151
000106  b995              CBNZ     r5,|L14.302|
000108  f89d4008          LDRB     r4,[sp,#8]            ;152
00010c  b10c              CBZ      r4,|L14.274|
00010e  2402              MOVS     r4,#2                 ;153
000110  e000              B        |L14.276|
                  |L14.274|
000112  2401              MOVS     r4,#1                 ;153
                  |L14.276|
000114  4d48              LDR      r5,|L14.568|
000116  440d              ADD      r5,r5,r1              ;153
000118  606c              STR      r4,[r5,#4]            ;153
00011a  9c01              LDR      r4,[sp,#4]            ;154
00011c  1e64              SUBS     r4,r4,#1              ;154
00011e  4d46              LDR      r5,|L14.568|
000120  440d              ADD      r5,r5,r1              ;154
000122  62ac              STR      r4,[r5,#0x28]         ;154
000124  2400              MOVS     r4,#0                 ;155
000126  4d44              LDR      r5,|L14.568|
000128  440d              ADD      r5,r5,r1              ;155
00012a  63ac              STR      r4,[r5,#0x38]         ;155
00012c  e011              B        |L14.338|
                  |L14.302|
00012e  f89d4008          LDRB     r4,[sp,#8]            ;157
000132  b10c              CBZ      r4,|L14.312|
000134  2402              MOVS     r4,#2                 ;158
000136  e000              B        |L14.314|
                  |L14.312|
000138  2401              MOVS     r4,#1                 ;158
                  |L14.314|
00013a  4d3f              LDR      r5,|L14.568|
00013c  440d              ADD      r5,r5,r1              ;158
00013e  60ac              STR      r4,[r5,#8]            ;158
000140  9c01              LDR      r4,[sp,#4]            ;159
000142  1e64              SUBS     r4,r4,#1              ;159
000144  4d3c              LDR      r5,|L14.568|
000146  440d              ADD      r5,r5,r1              ;159
000148  62ec              STR      r4,[r5,#0x2c]         ;159
00014a  2400              MOVS     r4,#0                 ;160
00014c  4d3a              LDR      r5,|L14.568|
00014e  440d              ADD      r5,r5,r1              ;160
000150  63ec              STR      r4,[r5,#0x3c]         ;160
                  |L14.338|
000152  4604              MOV      r4,r0                 ;164
000154  eb0075d4          ADD      r5,r0,r4,LSR #31      ;164
000158  106d              ASRS     r5,r5,#1              ;164
00015a  eba00545          SUB      r5,r0,r5,LSL #1       ;164
00015e  b90d              CBNZ     r5,|L14.356|
000160  2501              MOVS     r5,#1                 ;165
000162  e001              B        |L14.360|
                  |L14.356|
000164  f44f7580          MOV      r5,#0x100             ;165
                  |L14.360|
000168  4e33              LDR      r6,|L14.568|
00016a  440e              ADD      r6,r6,r1              ;165
00016c  6a76              LDR      r6,[r6,#0x24]         ;165
00016e  4335              ORRS     r5,r5,r6              ;165
000170  4e31              LDR      r6,|L14.568|
000172  440e              ADD      r6,r6,r1              ;165
000174  6275              STR      r5,[r6,#0x24]         ;165
000176  4604              MOV      r4,r0                 ;168
000178  eb0075d4          ADD      r5,r0,r4,LSR #31      ;168
00017c  106d              ASRS     r5,r5,#1              ;168
00017e  eba00545          SUB      r5,r0,r5,LSL #1       ;168
000182  b90d              CBNZ     r5,|L14.392|
000184  2501              MOVS     r5,#1                 ;169
000186  e001              B        |L14.396|
                  |L14.392|
000188  f44f7580          MOV      r5,#0x100             ;169
                  |L14.396|
00018c  4e2a              LDR      r6,|L14.568|
00018e  440e              ADD      r6,r6,r1              ;169
000190  69b6              LDR      r6,[r6,#0x18]         ;169
000192  4335              ORRS     r5,r5,r6              ;169
000194  4e28              LDR      r6,|L14.568|
000196  440e              ADD      r6,r6,r1              ;169
000198  61b5              STR      r5,[r6,#0x18]         ;169
00019a  f04f32ff          MOV      r2,#0xffffffff        ;172
00019e  f89d4009          LDRB     r4,[sp,#9]            ;173
0001a2  0163              LSLS     r3,r4,#5              ;173
0001a4  eb000480          ADD      r4,r0,r0,LSL #2       ;178
0001a8  4d1f              LDR      r5,|L14.552|
0001aa  f8154024          LDRB     r4,[r5,r4,LSL #2]     ;178
0001ae  00e5              LSLS     r5,r4,#3              ;178
0001b0  24ff              MOVS     r4,#0xff              ;178
0001b2  40ac              LSLS     r4,r4,r5              ;178
0001b4  43a2              BICS     r2,r2,r4              ;178
0001b6  eb000480          ADD      r4,r0,r0,LSL #2       ;179
0001ba  4d1b              LDR      r5,|L14.552|
0001bc  f8154024          LDRB     r4,[r5,r4,LSL #2]     ;179
0001c0  00e4              LSLS     r4,r4,#3              ;179
0001c2  40a3              LSLS     r3,r3,r4              ;179
0001c4  eb000480          ADD      r4,r0,r0,LSL #2       ;180
0001c8  eb050484          ADD      r4,r5,r4,LSL #2       ;180
0001cc  6864              LDR      r4,[r4,#4]            ;180
0001ce  6824              LDR      r4,[r4,#0]            ;180
0001d0  4014              ANDS     r4,r4,r2              ;180
0001d2  431c              ORRS     r4,r4,r3              ;180
0001d4  eb000580          ADD      r5,r0,r0,LSL #2       ;180
0001d8  4e13              LDR      r6,|L14.552|
0001da  eb060585          ADD      r5,r6,r5,LSL #2       ;180
0001de  686d              LDR      r5,[r5,#4]            ;180
0001e0  602c              STR      r4,[r5,#0]            ;180
0001e2  eb000480          ADD      r4,r0,r0,LSL #2       ;184
0001e6  4635              MOV      r5,r6                 ;184
0001e8  eb050484          ADD      r4,r5,r4,LSL #2       ;184
0001ec  7b25              LDRB     r5,[r4,#0xc]          ;184
0001ee  2401              MOVS     r4,#1                 ;184
0001f0  40ac              LSLS     r4,r4,r5              ;184
0001f2  eb000580          ADD      r5,r0,r0,LSL #2       ;184
0001f6  eb060585          ADD      r5,r6,r5,LSL #2       ;184
0001fa  68ad              LDR      r5,[r5,#8]            ;184
0001fc  602c              STR      r4,[r5,#0]            ;184
0001fe  4604              MOV      r4,r0                 ;187
000200  eb0075d4          ADD      r5,r0,r4,LSR #31      ;187
000204  106d              ASRS     r5,r5,#1              ;187
000206  eba00545          SUB      r5,r0,r5,LSL #1       ;187
00020a  b90d              CBNZ     r5,|L14.528|
00020c  2501              MOVS     r5,#1                 ;188
00020e  e001              B        |L14.532|
                  |L14.528|
000210  f44f7580          MOV      r5,#0x100             ;188
                  |L14.532|
000214  4e08              LDR      r6,|L14.568|
000216  440e              ADD      r6,r6,r1              ;188
000218  68f6              LDR      r6,[r6,#0xc]          ;188
00021a  4335              ORRS     r5,r5,r6              ;188
00021c  4e06              LDR      r6,|L14.568|
00021e  440e              ADD      r6,r6,r1              ;188
000220  60f5              STR      r5,[r6,#0xc]          ;188
000222  bf00              NOP      
000224  e6f5              B        |L14.18|
;;;190    
                          ENDP

000226  0000              DCW      0x0000
                  |L14.552|
                          DCD      interruptSettings
                  |L14.556|
                          DCD      0xe000ed20
                  |L14.560|
                          DCD      0x400fe604
                  |L14.564|
                          DCD      0x400fea04
                  |L14.568|
                          DCD      0x40030000

                          AREA ||i.TimerStop||, CODE, READONLY, ALIGN=2

                  TimerStop PROC
;;;236     */
;;;237    void TimerStop(TimerID_t timerID) {
000000  b530              PUSH     {r4,r5,lr}
000002  4601              MOV      r1,r0
;;;238        uint8_t ID = timerID;
000004  4608              MOV      r0,r1
;;;239    
;;;240        /* Early return on invalid timer enum or invalid priority. */
;;;241        if (ID == TIMER_COUNT) return;
000006  2819              CMP      r0,#0x19
000008  d100              BNE      |L15.12|
                  |L15.10|
;;;242        
;;;243        /* Special case for SYSTICK. */
;;;244        if (ID == SYSTICK) {    
;;;245            /* Disable during setup. */
;;;246            GET_REG(PERIPHERALS_BASE + SYSTICK_CTRL_OFFSET) = 0x00000000;
;;;247            return;
;;;248        }
;;;249    
;;;250        /* 1. We'll generate the timer offset to find the correct addresses for each
;;;251         * timer. */
;;;252        uint32_t timerOffset = 0;
;;;253    
;;;254        /* Timers TIMER_0A to WTIMER_1B. */
;;;255        if (ID < WTIMER_2A) timerOffset = 0x1000 * (uint32_t)(ID >> 1);
;;;256    
;;;257        /* Timers WTIMER_2A to WTIMER_5B. Jump the base to 0x4004.C000. Our magic
;;;258         * number, 16, is the enumerated value of WTIMER_2A. */
;;;259        else timerOffset = 0x1000 * (uint32_t)((ID-16) >> 1) + 0x0001C000;
;;;260    
;;;261        /* Step 2. Disable timer during setup. */
;;;262        GET_REG(GPTM_BASE + timerOffset + GPTMCTL_OFFSET) &=
;;;263            ((ID % 2) == 0) ? 0xFFFFFF00 : 0xFFFFFF00FF;
;;;264    }
00000a  bd30              POP      {r4,r5,pc}
                  |L15.12|
00000c  2818              CMP      r0,#0x18              ;244
00000e  d104              BNE      |L15.26|
000010  2300              MOVS     r3,#0                 ;246
000012  f04f24e0          MOV      r4,#0xe000e000        ;246
000016  6123              STR      r3,[r4,#0x10]         ;246
000018  e7f7              B        |L15.10|
                  |L15.26|
00001a  2200              MOVS     r2,#0                 ;252
00001c  2810              CMP      r0,#0x10              ;255
00001e  da02              BGE      |L15.38|
000020  1043              ASRS     r3,r0,#1              ;255
000022  031a              LSLS     r2,r3,#12             ;255
000024  e005              B        |L15.50|
                  |L15.38|
000026  f1a00310          SUB      r3,r0,#0x10           ;259
00002a  105b              ASRS     r3,r3,#1              ;259
00002c  031b              LSLS     r3,r3,#12             ;259
00002e  f50332e0          ADD      r2,r3,#0x1c000        ;259
                  |L15.50|
000032  4603              MOV      r3,r0                 ;262
000034  eb0074d3          ADD      r4,r0,r3,LSR #31      ;262
000038  1064              ASRS     r4,r4,#1              ;262
00003a  eba00444          SUB      r4,r0,r4,LSL #1       ;262
00003e  b914              CBNZ     r4,|L15.70|
000040  f06f04ff          MVN      r4,#0xff              ;263
000044  e001              B        |L15.74|
                  |L15.70|
000046  f46f447f          MVN      r4,#0xff00            ;263
                  |L15.74|
00004a  4d04              LDR      r5,|L15.92|
00004c  4415              ADD      r5,r5,r2              ;263
00004e  68ed              LDR      r5,[r5,#0xc]          ;263
000050  402c              ANDS     r4,r4,r5              ;263
000052  4d02              LDR      r5,|L15.92|
000054  4415              ADD      r5,r5,r2              ;263
000056  60ec              STR      r4,[r5,#0xc]          ;263
000058  bf00              NOP      
00005a  e7d6              B        |L15.10|
;;;265    
                          ENDP

                  |L15.92|
                          DCD      0x40030000

                          AREA ||i.TimerUpdatePeriod||, CODE, READONLY, ALIGN=2

                  TimerUpdatePeriod PROC
;;;197     */
;;;198    void TimerUpdatePeriod(TimerID_t timerID, uint32_t period) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;199        uint8_t ID = timerID;
000006  4610              MOV      r0,r2
;;;200    
;;;201        /* Early return on invalid timer enum or invalid priority. */
;;;202        if (ID == TIMER_COUNT) return;
000008  2819              CMP      r0,#0x19
00000a  d100              BNE      |L16.14|
                  |L16.12|
;;;203        
;;;204        /* Special case for SYSTICK. */
;;;205        if (ID == SYSTICK) {
;;;206            /* Set reload value. */
;;;207            GET_REG(PERIPHERALS_BASE + SYSTICK_LOAD_OFFSET) = period - 1;
;;;208            return;
;;;209        }
;;;210    
;;;211        /* 1. We'll generate the timer offset to find the correct addresses for each
;;;212         * timer. */
;;;213        uint32_t timerOffset = 0;
;;;214    
;;;215        /* Timers TIMER_0A to WTIMER_1B. */
;;;216        if (ID < WTIMER_2A) timerOffset = 0x1000 * (uint32_t)(ID >> 1);
;;;217    
;;;218        /* Timers WTIMER_2A to WTIMER_5B. Jump the base to 0x4004.C000. Our magic
;;;219         * number, 16, is the enumerated value of WTIMER_2A. */
;;;220        else timerOffset = 0x1000 * (uint32_t)((ID-16) >> 1) + 0x0001C000;
;;;221    
;;;222        /* Step 3. Update the period. */
;;;223        GET_REG(GPTM_BASE + timerOffset + GPTMTAILR_OFFSET) = period - 1;
;;;224    
;;;225    	/* Step 11. Enable timer after setup. */
;;;226        GET_REG(GPTM_BASE + timerOffset + GPTMCTL_OFFSET) |=
;;;227            ((ID % 2) == 0) ? 0x00000001 : 0x00000100;
;;;228    
;;;229        return;
;;;230    }
00000c  bd70              POP      {r4-r6,pc}
                  |L16.14|
00000e  2818              CMP      r0,#0x18              ;205
000010  d104              BNE      |L16.28|
000012  1e5c              SUBS     r4,r3,#1              ;207
000014  f04f25e0          MOV      r5,#0xe000e000        ;207
000018  616c              STR      r4,[r5,#0x14]         ;207
00001a  e7f7              B        |L16.12|
                  |L16.28|
00001c  2100              MOVS     r1,#0                 ;213
00001e  2810              CMP      r0,#0x10              ;216
000020  da02              BGE      |L16.40|
000022  1044              ASRS     r4,r0,#1              ;216
000024  0321              LSLS     r1,r4,#12             ;216
000026  e005              B        |L16.52|
                  |L16.40|
000028  f1a00410          SUB      r4,r0,#0x10           ;220
00002c  1064              ASRS     r4,r4,#1              ;220
00002e  0324              LSLS     r4,r4,#12             ;220
000030  f50431e0          ADD      r1,r4,#0x1c000        ;220
                  |L16.52|
000034  1e5c              SUBS     r4,r3,#1              ;223
000036  4d0b              LDR      r5,|L16.100|
000038  440d              ADD      r5,r5,r1              ;223
00003a  62ac              STR      r4,[r5,#0x28]         ;223
00003c  4604              MOV      r4,r0                 ;226
00003e  eb0075d4          ADD      r5,r0,r4,LSR #31      ;226
000042  106d              ASRS     r5,r5,#1              ;226
000044  eba00545          SUB      r5,r0,r5,LSL #1       ;226
000048  b90d              CBNZ     r5,|L16.78|
00004a  2501              MOVS     r5,#1                 ;227
00004c  e001              B        |L16.82|
                  |L16.78|
00004e  f44f7580          MOV      r5,#0x100             ;227
                  |L16.82|
000052  4e04              LDR      r6,|L16.100|
000054  440e              ADD      r6,r6,r1              ;227
000056  68f6              LDR      r6,[r6,#0xc]          ;227
000058  4335              ORRS     r5,r5,r6              ;227
00005a  4e02              LDR      r6,|L16.100|
00005c  440e              ADD      r6,r6,r1              ;227
00005e  60f5              STR      r5,[r6,#0xc]          ;227
000060  bf00              NOP                            ;229
000062  e7d3              B        |L16.12|
;;;231    
                          ENDP

                  |L16.100|
                          DCD      0x40030000

                          AREA ||i.WideTimer0A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer0A_Handler PROC
;;;363    
;;;364    void WideTimer0A_Handler(void) {}
000000  4770              BX       lr
;;;365    void WideTimer0B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer0B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer0B_Handler PROC
;;;364    void WideTimer0A_Handler(void) {}
;;;365    void WideTimer0B_Handler(void) {}
000000  4770              BX       lr
;;;366    void WideTimer1A_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer1A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer1A_Handler PROC
;;;365    void WideTimer0B_Handler(void) {}
;;;366    void WideTimer1A_Handler(void) {}
000000  4770              BX       lr
;;;367    void WideTimer1B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer1B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer1B_Handler PROC
;;;366    void WideTimer1A_Handler(void) {}
;;;367    void WideTimer1B_Handler(void) {}
000000  4770              BX       lr
;;;368    void WideTimer2A_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer2A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer2A_Handler PROC
;;;367    void WideTimer1B_Handler(void) {}
;;;368    void WideTimer2A_Handler(void) {}
000000  4770              BX       lr
;;;369    void WideTimer2B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer2B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer2B_Handler PROC
;;;368    void WideTimer2A_Handler(void) {}
;;;369    void WideTimer2B_Handler(void) {}
000000  4770              BX       lr
;;;370    void WideTimer3A_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer3A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer3A_Handler PROC
;;;369    void WideTimer2B_Handler(void) {}
;;;370    void WideTimer3A_Handler(void) {}
000000  4770              BX       lr
;;;371    void WideTimer3B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer3B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer3B_Handler PROC
;;;370    void WideTimer3A_Handler(void) {}
;;;371    void WideTimer3B_Handler(void) {}
000000  4770              BX       lr
;;;372    void WideTimer4A_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer4A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer4A_Handler PROC
;;;371    void WideTimer3B_Handler(void) {}
;;;372    void WideTimer4A_Handler(void) {}
000000  4770              BX       lr
;;;373    void WideTimer4B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer4B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer4B_Handler PROC
;;;372    void WideTimer4A_Handler(void) {}
;;;373    void WideTimer4B_Handler(void) {}
000000  4770              BX       lr
;;;374    void WideTimer5A_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer5A_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer5A_Handler PROC
;;;373    void WideTimer4B_Handler(void) {}
;;;374    void WideTimer5A_Handler(void) {}
000000  4770              BX       lr
;;;375    void WideTimer5B_Handler(void) {}
                          ENDP


                          AREA ||i.WideTimer5B_Handler||, CODE, READONLY, ALIGN=1

                  WideTimer5B_Handler PROC
;;;374    void WideTimer5A_Handler(void) {}
;;;375    void WideTimer5B_Handler(void) {}
000000  4770              BX       lr
;;;376    
                          ENDP


                          AREA ||i.freqToPeriod||, CODE, READONLY, ALIGN=1

                  freqToPeriod PROC
;;;275     */
;;;276    uint32_t freqToPeriod(uint32_t freq, uint32_t maxFreq) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;277        return (uint32_t) ceil(maxFreq/freq);
000008  fbb9faf4          UDIV     r10,r9,r4
00000c  4650              MOV      r0,r10
00000e  f7fffffe          BL       __aeabi_ui2d
000012  4607              MOV      r7,r0
000014  f7fffffe          BL       ceil
000018  4605              MOV      r5,r0
00001a  f7fffffe          BL       __aeabi_d2uiz
;;;278    }
00001e  e8bd87f0          POP      {r4-r10,pc}
;;;279    
                          ENDP


                          AREA ||i.getTick||, CODE, READONLY, ALIGN=2

                  getTick PROC
;;;391     */
;;;392    uint64_t getTick(void) {
000000  4901              LDR      r1,|L30.8|
;;;393        return tick;
000002  c903              LDM      r1,{r0,r1}
;;;394    }
000004  4770              BX       lr
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      tick

                          AREA ||.data||, DATA, ALIGN=3

                  interruptSettings
000000  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e410
                          DCD      0xe000e100
                          DCD      0x00000013
                          DCD      0x00000000
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e414
                          DCD      0xe000e100
                          DCD      0x00000014
                          DCD      0x00000000
000028  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0xe000e414
                          DCD      0xe000e100
                          DCD      0x00000015
                          DCD      0x00000000
00003c  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e414
                          DCD      0xe000e100
                          DCD      0x00000016
                          DCD      0x00000000
000050  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e414
                          DCD      0xe000e100
                          DCD      0x00000017
                          DCD      0x00000000
000064  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e418
                          DCD      0xe000e100
                          DCD      0x00000018
                          DCD      0x00000000
000078  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e420
                          DCD      0xe000e104
                          DCD      0x00000003
                          DCD      0x00000000
00008c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e424
                          DCD      0xe000e104
                          DCD      0x00000004
                          DCD      0x00000000
0000a0  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e444
                          DCD      0xe000e108
                          DCD      0x00000006
                          DCD      0x00000000
0000b4  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e444
                          DCD      0xe000e108
                          DCD      0x00000007
                          DCD      0x00000000
0000c8  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e45c
                          DCD      0xe000e108
                          DCD      0x0000001c
                          DCD      0x00000000
0000dc  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0xe000e45c
                          DCD      0xe000e108
                          DCD      0x0000001d
                          DCD      0x00000000
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          %        240
                          DCD      0x00000000
                  tick
0001f8  00000000          DCQ      0x0000000000000000
0001fc  00000000
