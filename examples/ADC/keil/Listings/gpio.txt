; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I.. -I../../.. -IC:\Users\matth\AppData\Local\Arm\Packs\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DTM4C123GH6PM -Drvmdk -DPART_LM4F120H5QR --omf_browse=.\objects\gpio.crf ..\..\..\lib\GPIO\GPIO.c]
                          THUMB

                          AREA ||i.GPIOGeneric_Handler||, CODE, READONLY, ALIGN=2

                  GPIOGeneric_Handler PROC
;;;259    /** Internal handler to manage GPIO interrupts. */
;;;260    void GPIOGeneric_Handler(pin_t pin) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;261        /** 1. Generate the port offset to find the correct addresses.
;;;262         *    There are a couple components in this line:
;;;263         * 
;;;264         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;265         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;266         *    details.
;;;267         * 
;;;268         *    (((pin - XXX) >> 3) << 12) : 
;;;269         *          Every group of eight pins belongs to the same port, and every
;;;270         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;271         *          in the datasheet). This expression right shifts the pin to mask
;;;272         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;273         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;274         *          GPIO_PORT_BASE to get the port address.
;;;275         * 
;;;276         *          The term `- XXX` is a conditional expanded to the following:
;;;277         * 
;;;278         *                        XXX = ((pin >= PIN_E0) << 5)
;;;279         * 
;;;280         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;281         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;282         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;283         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;284         * 
;;;285         *    + (pin >= PIN_E0) << 17 : 
;;;286         *          Port E and F are special in that they requires an
;;;287         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;288         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;289         */
;;;290        uint32_t portOffset = 
000006  2e20              CMP      r6,#0x20
000008  db01              BLT      |L1.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L1.16|
                  |L1.14|
00000e  2000              MOVS     r0,#0
                  |L1.16|
000010  eba61040          SUB      r0,r6,r0,LSL #5
000014  10c0              ASRS     r0,r0,#3
000016  0300              LSLS     r0,r0,#12
000018  2e20              CMP      r6,#0x20
00001a  db01              BLT      |L1.32|
00001c  2101              MOVS     r1,#1
00001e  e000              B        |L1.34|
                  |L1.32|
000020  2100              MOVS     r1,#0
                  |L1.34|
000022  eb004741          ADD      r7,r0,r1,LSL #17
;;;291            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;292    
;;;293        /* 2. Find which pin triggered an interrupt. Could be multiple at once. */
;;;294        uint8_t i;
;;;295        for (i = 0; i < 8; i++) {
000026  2500              MOVS     r5,#0
000028  e064              B        |L1.244|
                  |L1.42|
;;;296            if (GET_REG(GPIO_PORT_BASE + portOffset + GPIO_MIS_OFFSET) & (0x1 << i)) {
00002a  4834              LDR      r0,|L1.252|
00002c  59c0              LDR      r0,[r0,r7]
00002e  2101              MOVS     r1,#1
000030  40a9              LSLS     r1,r1,r5
000032  4008              ANDS     r0,r0,r1
000034  2800              CMP      r0,#0
000036  d05b              BEQ      |L1.240|
;;;297                /* Acknowledge interrupt flag. */
;;;298                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ICR_OFFSET) |= 0x1 << i;
000038  4830              LDR      r0,|L1.252|
00003a  1d00              ADDS     r0,r0,#4
00003c  59c1              LDR      r1,[r0,r7]
00003e  2001              MOVS     r0,#1
000040  40a8              LSLS     r0,r0,r5
000042  4308              ORRS     r0,r0,r1
000044  492d              LDR      r1,|L1.252|
000046  1d09              ADDS     r1,r1,#4
000048  51c8              STR      r0,[r1,r7]
;;;299                
;;;300                /* Get pin number. */
;;;301                pin_t pinIdx = (pin_t)(pin + i);
00004a  1970              ADDS     r0,r6,r5
00004c  b2c4              UXTB     r4,r0
;;;302    
;;;303                if (GPIOIntConfig[pinIdx].touchTask != NULL && GPIOIntConfig[pinIdx].releaseTask != NULL) {
00004e  482c              LDR      r0,|L1.256|
000050  eb001004          ADD      r0,r0,r4,LSL #4
000054  6840              LDR      r0,[r0,#4]
000056  b378              CBZ      r0,|L1.184|
000058  4829              LDR      r0,|L1.256|
00005a  eb001004          ADD      r0,r0,r4,LSL #4
00005e  6880              LDR      r0,[r0,#8]
000060  b350              CBZ      r0,|L1.184|
;;;304                    /* Both edge triggered. */
;;;305                    /* Get pin status. */
;;;306                    bool status = GPIOGetBit(pinIdx);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       GPIOGetBit
000068  4680              MOV      r8,r0
;;;307                    /* Figure out if rising or falling edge by reading the data register. */
;;;308                    if (status == 1 && GPIOIntConfig[pinIdx].pinStatus == LOWERED) {
00006a  f1b80f00          CMP      r8,#0
00006e  d00f              BEQ      |L1.144|
000070  4823              LDR      r0,|L1.256|
000072  eb001004          ADD      r0,r0,r4,LSL #4
000076  7b00              LDRB     r0,[r0,#0xc]
000078  b950              CBNZ     r0,|L1.144|
;;;309                        /* Rising edge. */
;;;310                        GPIOIntConfig[pinIdx].touchTask();
00007a  4921              LDR      r1,|L1.256|
00007c  eb011104          ADD      r1,r1,r4,LSL #4
000080  6848              LDR      r0,[r1,#4]
000082  4780              BLX      r0
;;;311                        GPIOIntConfig[pinIdx].pinStatus = RAISED;
000084  2001              MOVS     r0,#1
000086  491e              LDR      r1,|L1.256|
000088  eb011104          ADD      r1,r1,r4,LSL #4
00008c  7308              STRB     r0,[r1,#0xc]
00008e  e012              B        |L1.182|
                  |L1.144|
;;;312                    } else if (status == 0 && GPIOIntConfig[pinIdx].pinStatus == RAISED){
000090  f1b80f00          CMP      r8,#0
000094  d10f              BNE      |L1.182|
000096  481a              LDR      r0,|L1.256|
000098  eb001004          ADD      r0,r0,r4,LSL #4
00009c  7b00              LDRB     r0,[r0,#0xc]
00009e  2801              CMP      r0,#1
0000a0  d109              BNE      |L1.182|
;;;313                        /* Falling edge. */
;;;314                        GPIOIntConfig[pinIdx].releaseTask();
0000a2  4917              LDR      r1,|L1.256|
0000a4  eb011104          ADD      r1,r1,r4,LSL #4
0000a8  6888              LDR      r0,[r1,#8]
0000aa  4780              BLX      r0
;;;315                        GPIOIntConfig[pinIdx].pinStatus = LOWERED;
0000ac  2000              MOVS     r0,#0
0000ae  4914              LDR      r1,|L1.256|
0000b0  eb011104          ADD      r1,r1,r4,LSL #4
0000b4  7308              STRB     r0,[r1,#0xc]
                  |L1.182|
;;;316                    }
;;;317                } else if (GPIOIntConfig[pinIdx].touchTask != NULL) {
0000b6  e01a              B        |L1.238|
                  |L1.184|
0000b8  e7ff              B        |L1.186|
                  |L1.186|
0000ba  4811              LDR      r0,|L1.256|
0000bc  eb001004          ADD      r0,r0,r4,LSL #4
0000c0  6840              LDR      r0,[r0,#4]
0000c2  b150              CBZ      r0,|L1.218|
;;;318                    /* Rising edge trigger. */
;;;319                    GPIOIntConfig[pinIdx].touchTask();
0000c4  490e              LDR      r1,|L1.256|
0000c6  eb011104          ADD      r1,r1,r4,LSL #4
0000ca  6848              LDR      r0,[r1,#4]
0000cc  4780              BLX      r0
;;;320                    GPIOIntConfig[pinIdx].pinStatus = RAISED;
0000ce  2001              MOVS     r0,#1
0000d0  490b              LDR      r1,|L1.256|
0000d2  eb011104          ADD      r1,r1,r4,LSL #4
0000d6  7308              STRB     r0,[r1,#0xc]
0000d8  e009              B        |L1.238|
                  |L1.218|
;;;321                } else {
;;;322                    /* Falling edge trigger. */
;;;323                    GPIOIntConfig[pinIdx].releaseTask();
0000da  4909              LDR      r1,|L1.256|
0000dc  eb011104          ADD      r1,r1,r4,LSL #4
0000e0  6888              LDR      r0,[r1,#8]
0000e2  4780              BLX      r0
;;;324                    GPIOIntConfig[pinIdx].pinStatus = LOWERED;
0000e4  2000              MOVS     r0,#0
0000e6  4906              LDR      r1,|L1.256|
0000e8  eb011104          ADD      r1,r1,r4,LSL #4
0000ec  7308              STRB     r0,[r1,#0xc]
                  |L1.238|
;;;325                }
;;;326            }
0000ee  bf00              NOP      
                  |L1.240|
0000f0  1c68              ADDS     r0,r5,#1              ;295
0000f2  b2c5              UXTB     r5,r0                 ;295
                  |L1.244|
0000f4  2d08              CMP      r5,#8                 ;295
0000f6  db98              BLT      |L1.42|
;;;327        }
;;;328    }
0000f8  e8bd81f0          POP      {r4-r8,pc}
;;;329    
                          ENDP

                  |L1.252|
                          DCD      0x40004418
                  |L1.256|
                          DCD      GPIOIntConfig

                          AREA ||i.GPIOGetBit||, CODE, READONLY, ALIGN=1

                  GPIOGetBit PROC
;;;695     */
;;;696    bool GPIOGetBit(pin_t pin) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;697        /* Early return on invalid pin_t value. */
;;;698        if (pin >= PIN_COUNT) return 0;
000004  2930              CMP      r1,#0x30
000006  db01              BLT      |L2.12|
000008  2000              MOVS     r0,#0
                  |L2.10|
;;;699    
;;;700        /** 1. Generate the port offset to find the correct addresses.
;;;701         *    There are a couple components in this line:
;;;702         * 
;;;703         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;704         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;705         *    details.
;;;706         * 
;;;707         *    (((pin - XXX >> 3) << 12) : 
;;;708         *          Every group of eight pins belongs to the same port, and every
;;;709         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;710         *          in the datasheet). This expression right shifts the pin to mask
;;;711         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;712         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;713         *          GPIO_PORT_BASE to get the port address.
;;;714         * 
;;;715         *          The term `- XXX` is a conditional expanded to the following:
;;;716         * 
;;;717         *                        XXX = ((pin >= PIN_E0) << 5)
;;;718         * 
;;;719         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;720         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;721         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;722         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;723         * 
;;;724         *    + (pin >= PIN_E0) << 17 : 
;;;725         *          Port E and F are special in that they requires an
;;;726         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;727         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;728         */
;;;729        uint32_t portOffset = 
;;;730            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;731    
;;;732        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;733        return GET_REG(GPIO_PORT_BASE + portOffset + (1 << ((pin & 0x07) + 2)));
;;;734    }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  2920              CMP      r1,#0x20              ;729
00000e  db01              BLT      |L2.20|
000010  2001              MOVS     r0,#1                 ;729
000012  e000              B        |L2.22|
                  |L2.20|
000014  2000              MOVS     r0,#0                 ;729
                  |L2.22|
000016  eba11040          SUB      r0,r1,r0,LSL #5       ;729
00001a  10c0              ASRS     r0,r0,#3              ;729
00001c  0300              LSLS     r0,r0,#12             ;729
00001e  2920              CMP      r1,#0x20              ;729
000020  db01              BLT      |L2.38|
000022  2301              MOVS     r3,#1                 ;729
000024  e000              B        |L2.40|
                  |L2.38|
000026  2300              MOVS     r3,#0                 ;729
                  |L2.40|
000028  eb004243          ADD      r2,r0,r3,LSL #17      ;729
00002c  f1022040          ADD      r0,r2,#0x40004000     ;733
000030  f0010307          AND      r3,r1,#7              ;733
000034  1c9b              ADDS     r3,r3,#2              ;733
000036  2401              MOVS     r4,#1                 ;733
000038  409c              LSLS     r4,r4,r3              ;733
00003a  5900              LDR      r0,[r0,r4]            ;733
00003c  b108              CBZ      r0,|L2.66|
00003e  2001              MOVS     r0,#1                 ;733
000040  e7e3              B        |L2.10|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;733
000044  e7e1              B        |L2.10|
;;;735    #endif
                          ENDP


                          AREA ||i.GPIOInit||, CODE, READONLY, ALIGN=2

                  GPIOInit PROC
;;;65      */
;;;66     void GPIOInit(GPIOConfig_t pinConfig) {
000000  b573              PUSH     {r0,r1,r4-r6,lr}
000002  ed2d8b04          VPUSH    {d8-d9}
;;;67         /* Early return on invalid pin_t value. */
;;;68         if (pinConfig.GPIOPin >= PIN_COUNT) return;
000006  f89d0010          LDRB     r0,[sp,#0x10]
00000a  2830              CMP      r0,#0x30
00000c  db02              BLT      |L3.20|
                  |L3.14|
;;;69     
;;;70         /* 1. Activate the clock for the relevant port. */
;;;71         GET_REG(SYSCTL_BASE + SYSCTL_RCGCGPIO_OFFSET) |= 
;;;72             1 << (pinConfig.GPIOPin / 8); /* 8 pins per port. */
;;;73     
;;;74         /* 2. Stall until clock is ready. */
;;;75         while ((GET_REG(SYSCTL_BASE + SYSCTL_PRGPIO_OFFSET) & 
;;;76                (1 << (pinConfig.GPIOPin / 8))) == 0) {};
;;;77     
;;;78         /** 3. Generate the port offset to find the correct addresses.
;;;79          *    There are a couple components in this line:
;;;80          * 
;;;81          *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;82          *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;83          *    details.
;;;84          * 
;;;85          *    (((pin - XXX) >> 3) << 12) : 
;;;86          *          Every group of eight pins belongs to the same port, and every
;;;87          *          port has an offset of 0x1000 from each other (typically) (p.685
;;;88          *          in the datasheet). This expression right shifts the pin to mask
;;;89          *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;90          *          the offset (1 << 12 is 0x1000). This is later appended to
;;;91          *          GPIO_PORT_BASE to get the port address.
;;;92          * 
;;;93          *          The term `- XXX` is a conditional expanded to the following:
;;;94          * 
;;;95          *                        XXX = ((pin >= PIN_E0) << 5)
;;;96          * 
;;;97          *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;98          *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;99          *          enum value of PIN_E0) to get the correct port offset. This is 
;;;100         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;101         * 
;;;102         *    + (pin >= PIN_E0) << 17 : 
;;;103         *          Port E and F are special in that they requires an
;;;104         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;105         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;106         */
;;;107        uint32_t portOffset = 
;;;108            (((pinConfig.GPIOPin - ((pinConfig.GPIOPin >= PIN_E0) << 5)) >> 3) << 12) + 
;;;109            ((pinConfig.GPIOPin >= PIN_E0) << 17);
;;;110    
;;;111        /* 4. If PC0-3, PD7, PF0, unlock the port. */
;;;112        if (pinConfig.GPIOPin == PIN_C0 ||
;;;113            pinConfig.GPIOPin == PIN_C1 ||
;;;114            pinConfig.GPIOPin == PIN_C2 ||
;;;115            pinConfig.GPIOPin == PIN_C3 ||
;;;116            pinConfig.GPIOPin == PIN_D7 ||
;;;117            pinConfig.GPIOPin == PIN_F0 ) {
;;;118            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_LOCK_OFFSET) = GPIO_LOCK_KEY;
;;;119        }
;;;120    
;;;121        /* 5. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;122        uint8_t pinAddress = pow(2, pinConfig.GPIOPin % 8);
;;;123        
;;;124        /* 6. Allow changes to selected pin. */
;;;125        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_CR_OFFSET) |= pinAddress;
;;;126    
;;;127        /* 7. Set direction of pin. */
;;;128        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DIR_OFFSET) &= ~pinAddress;
;;;129        if (pinConfig.isOutput)
;;;130            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DIR_OFFSET) |= pinAddress;
;;;131    
;;;132        /* 8. Set alternative function if required. */
;;;133        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AFSEL_OFFSET) &= ~pinAddress;
;;;134        if (pinConfig.isAlternative) {
;;;135            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AFSEL_OFFSET) |= pinAddress;
;;;136            uint32_t mask = 0xFFFFFFFF;
;;;137            mask &= ~(0xF << ((pinConfig.GPIOPin % 8) * 4));
;;;138            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PCTL_OFFSET) &= mask;
;;;139            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PCTL_OFFSET) |=
;;;140                (pinConfig.alternateFunction << ((pinConfig.GPIOPin % 8) * 4));
;;;141        }
;;;142    
;;;143        /* 9. Set pin drive strength to 8mA. This step is performed by default. */
;;;144        GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DR8R_OFFSET) |= pinAddress;
;;;145    
;;;146        /* 10. Set pullup, pulldown, or open drain. */
;;;147        if (pinConfig.pull == PULL_UP) {
;;;148            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PUR_OFFSET) |= pinAddress;
;;;149        } else if (pinConfig.pull == PULL_DOWN) {
;;;150            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_PDR_OFFSET) |= pinAddress;
;;;151        } else if (pinConfig.pull == OPEN_DRAIN) {
;;;152            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ODR_OFFSET) |= pinAddress;
;;;153        }
;;;154    
;;;155        /* 11. Enable as digital or as analog pins. */
;;;156        if (pinConfig.isAnalog) {
;;;157            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_AMSEL_OFFSET) |= pinAddress;
;;;158        } else {
;;;159            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_DEN_OFFSET) |= pinAddress;
;;;160        }
;;;161    }
00000e  ecbd8b04          VPOP     {d8-d9}
000012  bd7c              POP      {r2-r6,pc}
                  |L3.20|
000014  f89d0010          LDRB     r0,[sp,#0x10]         ;71
000018  17c1              ASRS     r1,r0,#31             ;71
00001a  eb007151          ADD      r1,r0,r1,LSR #29      ;71
00001e  10ca              ASRS     r2,r1,#3              ;71
000020  2101              MOVS     r1,#1                 ;71
000022  4091              LSLS     r1,r1,r2              ;71
000024  4a73              LDR      r2,|L3.500|
000026  6812              LDR      r2,[r2,#0]            ;71
000028  4311              ORRS     r1,r1,r2              ;71
00002a  4a72              LDR      r2,|L3.500|
00002c  6011              STR      r1,[r2,#0]            ;71
00002e  bf00              NOP                            ;75
                  |L3.48|
000030  f89d0010          LDRB     r0,[sp,#0x10]         ;75
000034  17c1              ASRS     r1,r0,#31             ;75
000036  eb007151          ADD      r1,r0,r1,LSR #29      ;75
00003a  10ca              ASRS     r2,r1,#3              ;75
00003c  2101              MOVS     r1,#1                 ;75
00003e  4091              LSLS     r1,r1,r2              ;75
000040  4a6d              LDR      r2,|L3.504|
000042  6812              LDR      r2,[r2,#0]            ;75
000044  4011              ANDS     r1,r1,r2              ;75
000046  2900              CMP      r1,#0                 ;75
000048  d0f2              BEQ      |L3.48|
00004a  f89d0010          LDRB     r0,[sp,#0x10]         ;107
00004e  2820              CMP      r0,#0x20              ;107
000050  db01              BLT      |L3.86|
000052  2101              MOVS     r1,#1                 ;107
000054  e000              B        |L3.88|
                  |L3.86|
000056  2100              MOVS     r1,#0                 ;107
                  |L3.88|
000058  eba01041          SUB      r0,r0,r1,LSL #5       ;107
00005c  10c0              ASRS     r0,r0,#3              ;107
00005e  0300              LSLS     r0,r0,#12             ;107
000060  f89d1010          LDRB     r1,[sp,#0x10]         ;107
000064  2920              CMP      r1,#0x20              ;107
000066  db01              BLT      |L3.108|
000068  2101              MOVS     r1,#1                 ;107
00006a  e000              B        |L3.110|
                  |L3.108|
00006c  2100              MOVS     r1,#0                 ;107
                  |L3.110|
00006e  eb004441          ADD      r4,r0,r1,LSL #17      ;107
000072  f89d0010          LDRB     r0,[sp,#0x10]         ;112
000076  2810              CMP      r0,#0x10              ;112
000078  d013              BEQ      |L3.162|
00007a  f89d0010          LDRB     r0,[sp,#0x10]         ;113
00007e  2811              CMP      r0,#0x11              ;113
000080  d00f              BEQ      |L3.162|
000082  f89d0010          LDRB     r0,[sp,#0x10]         ;114
000086  2812              CMP      r0,#0x12              ;114
000088  d00b              BEQ      |L3.162|
00008a  f89d0010          LDRB     r0,[sp,#0x10]         ;115
00008e  2813              CMP      r0,#0x13              ;115
000090  d007              BEQ      |L3.162|
000092  f89d0010          LDRB     r0,[sp,#0x10]         ;116
000096  281f              CMP      r0,#0x1f              ;116
000098  d003              BEQ      |L3.162|
00009a  f89d0010          LDRB     r0,[sp,#0x10]         ;117
00009e  2828              CMP      r0,#0x28              ;117
0000a0  d102              BNE      |L3.168|
                  |L3.162|
0000a2  4956              LDR      r1,|L3.508|
0000a4  4856              LDR      r0,|L3.512|
0000a6  5101              STR      r1,[r0,r4]            ;118
                  |L3.168|
0000a8  f89d6010          LDRB     r6,[sp,#0x10]         ;122
0000ac  17f1              ASRS     r1,r6,#31             ;122
0000ae  eb067151          ADD      r1,r6,r1,LSR #29      ;122
0000b2  10c9              ASRS     r1,r1,#3              ;122
0000b4  eba600c1          SUB      r0,r6,r1,LSL #3       ;122
0000b8  f7fffffe          BL       __aeabi_i2d
0000bc  ec410b19          VMOV     d9,r0,r1              ;122
0000c0  eeb01a49          VMOV.F32 s2,s18                ;122
0000c4  eef01a69          VMOV.F32 s3,s19                ;122
0000c8  ed9f0b4e          VLDR     d0,|L3.516|
0000cc  f7fffffe          BL       __hardfp_pow
0000d0  eeb08a40          VMOV.F32 s16,s0                ;122
0000d4  eef08a60          VMOV.F32 s17,s1                ;122
0000d8  ec510b18          VMOV     r0,r1,d8              ;122
0000dc  f7fffffe          BL       __aeabi_d2uiz
0000e0  b2c5              UXTB     r5,r0                 ;122
0000e2  4847              LDR      r0,|L3.512|
0000e4  1d00              ADDS     r0,r0,#4              ;125
0000e6  5900              LDR      r0,[r0,r4]            ;125
0000e8  4328              ORRS     r0,r0,r5              ;125
0000ea  4945              LDR      r1,|L3.512|
0000ec  1d09              ADDS     r1,r1,#4              ;125
0000ee  5108              STR      r0,[r1,r4]            ;125
0000f0  4846              LDR      r0,|L3.524|
0000f2  5900              LDR      r0,[r0,r4]            ;128
0000f4  43a8              BICS     r0,r0,r5              ;128
0000f6  4945              LDR      r1,|L3.524|
0000f8  5108              STR      r0,[r1,r4]            ;128
0000fa  f89d0012          LDRB     r0,[sp,#0x12]         ;129
0000fe  b118              CBZ      r0,|L3.264|
000100  4608              MOV      r0,r1                 ;130
000102  5900              LDR      r0,[r0,r4]            ;130
000104  4328              ORRS     r0,r0,r5              ;130
000106  5108              STR      r0,[r1,r4]            ;130
                  |L3.264|
000108  4840              LDR      r0,|L3.524|
00010a  3020              ADDS     r0,r0,#0x20           ;133
00010c  5900              LDR      r0,[r0,r4]            ;133
00010e  43a8              BICS     r0,r0,r5              ;133
000110  493e              LDR      r1,|L3.524|
000112  3120              ADDS     r1,r1,#0x20           ;133
000114  5108              STR      r0,[r1,r4]            ;133
000116  f89d0013          LDRB     r0,[sp,#0x13]         ;134
00011a  b368              CBZ      r0,|L3.376|
00011c  4608              MOV      r0,r1                 ;135
00011e  5900              LDR      r0,[r0,r4]            ;135
000120  4328              ORRS     r0,r0,r5              ;135
000122  460a              MOV      r2,r1                 ;135
000124  5110              STR      r0,[r2,r4]            ;135
000126  f04f31ff          MOV      r1,#0xffffffff        ;136
00012a  f89d0010          LDRB     r0,[sp,#0x10]         ;137
00012e  17c2              ASRS     r2,r0,#31             ;137
000130  eb007252          ADD      r2,r0,r2,LSR #29      ;137
000134  10d2              ASRS     r2,r2,#3              ;137
000136  eba002c2          SUB      r2,r0,r2,LSL #3       ;137
00013a  0093              LSLS     r3,r2,#2              ;137
00013c  220f              MOVS     r2,#0xf               ;137
00013e  409a              LSLS     r2,r2,r3              ;137
000140  4391              BICS     r1,r1,r2              ;137
000142  482f              LDR      r0,|L3.512|
000144  300c              ADDS     r0,r0,#0xc            ;138
000146  5900              LDR      r0,[r0,r4]            ;138
000148  4008              ANDS     r0,r0,r1              ;138
00014a  4a2d              LDR      r2,|L3.512|
00014c  320c              ADDS     r2,r2,#0xc            ;138
00014e  5110              STR      r0,[r2,r4]            ;138
000150  f89d0010          LDRB     r0,[sp,#0x10]         ;139
000154  17c2              ASRS     r2,r0,#31             ;139
000156  eb007252          ADD      r2,r0,r2,LSR #29      ;139
00015a  10d2              ASRS     r2,r2,#3              ;139
00015c  eba002c2          SUB      r2,r0,r2,LSL #3       ;139
000160  0093              LSLS     r3,r2,#2              ;139
000162  f89d2014          LDRB     r2,[sp,#0x14]         ;139
000166  409a              LSLS     r2,r2,r3              ;139
000168  4b25              LDR      r3,|L3.512|
00016a  330c              ADDS     r3,r3,#0xc            ;139
00016c  591b              LDR      r3,[r3,r4]            ;139
00016e  431a              ORRS     r2,r2,r3              ;139
000170  4b23              LDR      r3,|L3.512|
000172  330c              ADDS     r3,r3,#0xc            ;139
000174  511a              STR      r2,[r3,r4]            ;139
000176  bf00              NOP                            ;141
                  |L3.376|
000178  4821              LDR      r0,|L3.512|
00017a  3818              SUBS     r0,r0,#0x18           ;144
00017c  5900              LDR      r0,[r0,r4]            ;144
00017e  4328              ORRS     r0,r0,r5              ;144
000180  491f              LDR      r1,|L3.512|
000182  3918              SUBS     r1,r1,#0x18           ;144
000184  5108              STR      r0,[r1,r4]            ;144
000186  f89d0011          LDRB     r0,[sp,#0x11]         ;147
00018a  b938              CBNZ     r0,|L3.412|
00018c  481c              LDR      r0,|L3.512|
00018e  3810              SUBS     r0,r0,#0x10           ;148
000190  5900              LDR      r0,[r0,r4]            ;148
000192  4328              ORRS     r0,r0,r5              ;148
000194  491a              LDR      r1,|L3.512|
000196  3910              SUBS     r1,r1,#0x10           ;148
000198  5108              STR      r0,[r1,r4]            ;148
00019a  e016              B        |L3.458|
                  |L3.412|
00019c  f89d0011          LDRB     r0,[sp,#0x11]         ;149
0001a0  2801              CMP      r0,#1                 ;149
0001a2  d107              BNE      |L3.436|
0001a4  4816              LDR      r0,|L3.512|
0001a6  380c              SUBS     r0,r0,#0xc            ;150
0001a8  5900              LDR      r0,[r0,r4]            ;150
0001aa  4328              ORRS     r0,r0,r5              ;150
0001ac  4914              LDR      r1,|L3.512|
0001ae  390c              SUBS     r1,r1,#0xc            ;150
0001b0  5108              STR      r0,[r1,r4]            ;150
0001b2  e00a              B        |L3.458|
                  |L3.436|
0001b4  f89d0011          LDRB     r0,[sp,#0x11]         ;151
0001b8  2802              CMP      r0,#2                 ;151
0001ba  d106              BNE      |L3.458|
0001bc  4810              LDR      r0,|L3.512|
0001be  3814              SUBS     r0,r0,#0x14           ;152
0001c0  5900              LDR      r0,[r0,r4]            ;152
0001c2  4328              ORRS     r0,r0,r5              ;152
0001c4  490e              LDR      r1,|L3.512|
0001c6  3914              SUBS     r1,r1,#0x14           ;152
0001c8  5108              STR      r0,[r1,r4]            ;152
                  |L3.458|
0001ca  f89d0015          LDRB     r0,[sp,#0x15]         ;156
0001ce  b138              CBZ      r0,|L3.480|
0001d0  480b              LDR      r0,|L3.512|
0001d2  3008              ADDS     r0,r0,#8              ;157
0001d4  5900              LDR      r0,[r0,r4]            ;157
0001d6  4328              ORRS     r0,r0,r5              ;157
0001d8  4909              LDR      r1,|L3.512|
0001da  3108              ADDS     r1,r1,#8              ;157
0001dc  5108              STR      r0,[r1,r4]            ;157
0001de  e006              B        |L3.494|
                  |L3.480|
0001e0  4807              LDR      r0,|L3.512|
0001e2  1f00              SUBS     r0,r0,#4              ;159
0001e4  5900              LDR      r0,[r0,r4]            ;159
0001e6  4328              ORRS     r0,r0,r5              ;159
0001e8  4905              LDR      r1,|L3.512|
0001ea  1f09              SUBS     r1,r1,#4              ;159
0001ec  5108              STR      r0,[r1,r4]            ;159
                  |L3.494|
0001ee  bf00              NOP      
0001f0  e70d              B        |L3.14|
;;;162    
                          ENDP

0001f2  0000              DCW      0x0000
                  |L3.500|
                          DCD      0x400fe608
                  |L3.504|
                          DCD      0x400fea08
                  |L3.508|
                          DCD      0x4c4f434b
                  |L3.512|
                          DCD      0x40004520
                  |L3.516|
000204  00000000          DCFD     0x4000000000000000 ; 2
000208  40000000
                  |L3.524|
                          DCD      0x40004400

                          AREA ||i.GPIOIntInit||, CODE, READONLY, ALIGN=2

                  GPIOIntInit PROC
;;;169     */
;;;170    void GPIOIntInit(GPIOConfig_t pinConfig, GPIOInterruptConfig_t pinIntConfig) {
000000  b40f              PUSH     {r0-r3}
000002  b570              PUSH     {r4-r6,lr}
000004  ed2d8b04          VPUSH    {d8-d9}
;;;171        /* Early return on invalid pin_t value. */
;;;172        if (pinConfig.GPIOPin >= PIN_COUNT) return;
000008  f89d0020          LDRB     r0,[sp,#0x20]
00000c  2830              CMP      r0,#0x30
00000e  db04              BLT      |L4.26|
                  |L4.16|
;;;173    
;;;174        GPIOInit(pinConfig);
;;;175    
;;;176        /** 1. Generate the port offset to find the correct addresses.
;;;177         *    There are a couple components in this line:
;;;178         * 
;;;179         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;180         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;181         *    details.
;;;182         * 
;;;183         *    (((pin - XXX) >> 3) << 12) : 
;;;184         *          Every group of eight pins belongs to the same port, and every
;;;185         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;186         *          in the datasheet). This expression right shifts the pin to mask
;;;187         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;188         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;189         *          GPIO_PORT_BASE to get the port address.
;;;190         * 
;;;191         *          The term `- XXX` is a conditional expanded to the following:
;;;192         * 
;;;193         *                        XXX = ((pin >= PIN_E0) << 5)
;;;194         * 
;;;195         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;196         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;197         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;198         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;199         * 
;;;200         *    + (pin >= PIN_E0) << 17 : 
;;;201         *          Port E and F are special in that they requires an
;;;202         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;203         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;204         */
;;;205        uint32_t portOffset = 
;;;206            (((pinConfig.GPIOPin - ((pinConfig.GPIOPin >= PIN_E0) << 5)) >> 3) << 12) + 
;;;207            ((pinConfig.GPIOPin >= PIN_E0) << 17);
;;;208    
;;;209        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;210        uint8_t pinAddress = pow(2, pinConfig.GPIOPin % 8);
;;;211    
;;;212        /* 3. Enable interrupts if required. */
;;;213        if (pinIntConfig.touchTask != NULL || pinIntConfig.releaseTask != NULL) {
;;;214            /* 4. Set pin as edge sensitive. */
;;;215            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IS_OFFSET) &= ~pinAddress;
;;;216            if (pinIntConfig.touchTask != NULL && pinIntConfig.releaseTask != NULL) {
;;;217                /* 5. Set pin to interrupt on both edges. */
;;;218                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IBE_OFFSET) |= pinAddress;
;;;219            } else {
;;;220                /* 6. Set pin to interrupt as dictated by GPIOIEV. */
;;;221                GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IBE_OFFSET) &= ~pinAddress;
;;;222                if (pinIntConfig.touchTask != NULL) {
;;;223                    /* 7. Set pin to interrupt on a rising edge. */
;;;224                    GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IEV_OFFSET) |= pinAddress;
;;;225                } else {
;;;226                    /* 8. Set pin to interrupt on a falling edge. */
;;;227                    GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IEV_OFFSET) &= ~pinAddress;
;;;228                }
;;;229            }
;;;230    
;;;231            /* 9. Clear flag for the pin. */
;;;232            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_ICR_OFFSET) |= pinAddress;
;;;233    
;;;234            /* 10. Arm interrupt for pin. */
;;;235            GET_REG(GPIO_PORT_BASE + portOffset + GPIO_IM_OFFSET) |= pinAddress;
;;;236    
;;;237            /* 11. Set GPIO interrupt priority. */
;;;238            uint8_t ID = pinConfig.GPIOPin/8;
;;;239            uint32_t mask = 0xFFFFFFFF;
;;;240            uint32_t intVal = pinIntConfig.priority << 5;
;;;241    
;;;242            /* Our magic number is 8 since to shift a hex value one hex position, we do
;;;243            * 4 binary shifts. To do it twice; 8 binary shifts. Our output should
;;;244            * something like this for priority 2: 0xFF00FFFF, 0x00400000. */
;;;245            mask &= ~(0xFF << (interruptSettings[ID].priorityIdx * 8));
;;;246            intVal = intVal << (interruptSettings[ID].priorityIdx * 8);
;;;247            (*interruptSettings[ID].NVIC_PRI_ADDR) = 
;;;248                ((*interruptSettings[ID].NVIC_PRI_ADDR)&mask)|intVal;
;;;249            
;;;250            /* 12. Enable IRQ X in NVIC. */
;;;251            (*interruptSettings[ID].NVIC_EN_ADDR) = 1 << interruptSettings[ID].IRQ;
;;;252    
;;;253        }
;;;254    
;;;255        /* 13. Assign configuration to the internal data structure. */
;;;256        GPIOIntConfig[pinConfig.GPIOPin] = pinIntConfig;
;;;257    }
000010  ecbd8b04          VPOP     {d8-d9}
000014  bc70              POP      {r4-r6}
000016  f85dfb14          LDR      pc,[sp],#0x14
                  |L4.26|
00001a  e9dd0108          LDRD     r0,r1,[sp,#0x20]      ;174
00001e  f7fffffe          BL       GPIOInit
000022  f89d0020          LDRB     r0,[sp,#0x20]         ;205
000026  2820              CMP      r0,#0x20              ;205
000028  db01              BLT      |L4.46|
00002a  2101              MOVS     r1,#1                 ;205
00002c  e000              B        |L4.48|
                  |L4.46|
00002e  2100              MOVS     r1,#0                 ;205
                  |L4.48|
000030  eba01041          SUB      r0,r0,r1,LSL #5       ;205
000034  10c0              ASRS     r0,r0,#3              ;205
000036  0300              LSLS     r0,r0,#12             ;205
000038  f89d1020          LDRB     r1,[sp,#0x20]         ;205
00003c  2920              CMP      r1,#0x20              ;205
00003e  db01              BLT      |L4.68|
000040  2101              MOVS     r1,#1                 ;205
000042  e000              B        |L4.70|
                  |L4.68|
000044  2100              MOVS     r1,#0                 ;205
                  |L4.70|
000046  eb004441          ADD      r4,r0,r1,LSL #17      ;205
00004a  f89d6020          LDRB     r6,[sp,#0x20]         ;210
00004e  17f1              ASRS     r1,r6,#31             ;210
000050  eb067151          ADD      r1,r6,r1,LSR #29      ;210
000054  10c9              ASRS     r1,r1,#3              ;210
000056  eba600c1          SUB      r0,r6,r1,LSL #3       ;210
00005a  f7fffffe          BL       __aeabi_i2d
00005e  ec410b19          VMOV     d9,r0,r1              ;210
000062  eeb01a49          VMOV.F32 s2,s18                ;210
000066  eef01a69          VMOV.F32 s3,s19                ;210
00006a  ed9f0b40          VLDR     d0,|L4.364|
00006e  f7fffffe          BL       __hardfp_pow
000072  eeb08a40          VMOV.F32 s16,s0                ;210
000076  eef08a60          VMOV.F32 s17,s1                ;210
00007a  ec510b18          VMOV     r0,r1,d8              ;210
00007e  f7fffffe          BL       __aeabi_d2uiz
000082  b2c5              UXTB     r5,r0                 ;210
000084  980b              LDR      r0,[sp,#0x2c]         ;213
000086  b910              CBNZ     r0,|L4.142|
000088  980c              LDR      r0,[sp,#0x30]         ;213
00008a  2800              CMP      r0,#0                 ;213
00008c  d063              BEQ      |L4.342|
                  |L4.142|
00008e  4b39              LDR      r3,|L4.372|
000090  591b              LDR      r3,[r3,r4]            ;215
000092  43ab              BICS     r3,r3,r5              ;215
000094  4e37              LDR      r6,|L4.372|
000096  5133              STR      r3,[r6,r4]            ;215
000098  9b0b              LDR      r3,[sp,#0x2c]         ;216
00009a  b13b              CBZ      r3,|L4.172|
00009c  9b0c              LDR      r3,[sp,#0x30]         ;216
00009e  b12b              CBZ      r3,|L4.172|
0000a0  1d33              ADDS     r3,r6,#4              ;218
0000a2  591b              LDR      r3,[r3,r4]            ;218
0000a4  432b              ORRS     r3,r3,r5              ;218
0000a6  1d36              ADDS     r6,r6,#4              ;218
0000a8  5133              STR      r3,[r6,r4]            ;218
0000aa  e015              B        |L4.216|
                  |L4.172|
0000ac  4b31              LDR      r3,|L4.372|
0000ae  1d1b              ADDS     r3,r3,#4              ;221
0000b0  591b              LDR      r3,[r3,r4]            ;221
0000b2  43ab              BICS     r3,r3,r5              ;221
0000b4  4e2f              LDR      r6,|L4.372|
0000b6  1d36              ADDS     r6,r6,#4              ;221
0000b8  5133              STR      r3,[r6,r4]            ;221
0000ba  9b0b              LDR      r3,[sp,#0x2c]         ;222
0000bc  b12b              CBZ      r3,|L4.202|
0000be  1d33              ADDS     r3,r6,#4              ;224
0000c0  591b              LDR      r3,[r3,r4]            ;224
0000c2  432b              ORRS     r3,r3,r5              ;224
0000c4  1d36              ADDS     r6,r6,#4              ;224
0000c6  5133              STR      r3,[r6,r4]            ;224
0000c8  e006              B        |L4.216|
                  |L4.202|
0000ca  4b2a              LDR      r3,|L4.372|
0000cc  3308              ADDS     r3,r3,#8              ;227
0000ce  591b              LDR      r3,[r3,r4]            ;227
0000d0  43ab              BICS     r3,r3,r5              ;227
0000d2  4e28              LDR      r6,|L4.372|
0000d4  3608              ADDS     r6,r6,#8              ;227
0000d6  5133              STR      r3,[r6,r4]            ;227
                  |L4.216|
0000d8  4b26              LDR      r3,|L4.372|
0000da  3318              ADDS     r3,r3,#0x18           ;232
0000dc  591b              LDR      r3,[r3,r4]            ;232
0000de  432b              ORRS     r3,r3,r5              ;232
0000e0  4e24              LDR      r6,|L4.372|
0000e2  3618              ADDS     r6,r6,#0x18           ;232
0000e4  5133              STR      r3,[r6,r4]            ;232
0000e6  4b23              LDR      r3,|L4.372|
0000e8  330c              ADDS     r3,r3,#0xc            ;235
0000ea  591b              LDR      r3,[r3,r4]            ;235
0000ec  432b              ORRS     r3,r3,r5              ;235
0000ee  4e21              LDR      r6,|L4.372|
0000f0  360c              ADDS     r6,r6,#0xc            ;235
0000f2  5133              STR      r3,[r6,r4]            ;235
0000f4  f89d3020          LDRB     r3,[sp,#0x20]         ;238
0000f8  17de              ASRS     r6,r3,#31             ;238
0000fa  eb037656          ADD      r6,r3,r6,LSR #29      ;238
0000fe  10f0              ASRS     r0,r6,#3              ;238
000100  f04f31ff          MOV      r1,#0xffffffff        ;239
000104  f89d3028          LDRB     r3,[sp,#0x28]         ;240
000108  015a              LSLS     r2,r3,#5              ;240
00010a  4b1b              LDR      r3,|L4.376|
00010c  eb031300          ADD      r3,r3,r0,LSL #4       ;245
000110  781b              LDRB     r3,[r3,#0]            ;245
000112  00de              LSLS     r6,r3,#3              ;245
000114  23ff              MOVS     r3,#0xff              ;245
000116  40b3              LSLS     r3,r3,r6              ;245
000118  4399              BICS     r1,r1,r3              ;245
00011a  4b17              LDR      r3,|L4.376|
00011c  eb031300          ADD      r3,r3,r0,LSL #4       ;246
000120  781b              LDRB     r3,[r3,#0]            ;246
000122  00db              LSLS     r3,r3,#3              ;246
000124  409a              LSLS     r2,r2,r3              ;246
000126  4b14              LDR      r3,|L4.376|
000128  eb031300          ADD      r3,r3,r0,LSL #4       ;247
00012c  685b              LDR      r3,[r3,#4]            ;247
00012e  681b              LDR      r3,[r3,#0]            ;247
000130  400b              ANDS     r3,r3,r1              ;247
000132  4313              ORRS     r3,r3,r2              ;247
000134  4e10              LDR      r6,|L4.376|
000136  eb061600          ADD      r6,r6,r0,LSL #4       ;247
00013a  6876              LDR      r6,[r6,#4]            ;247
00013c  6033              STR      r3,[r6,#0]            ;247
00013e  4b0e              LDR      r3,|L4.376|
000140  eb031300          ADD      r3,r3,r0,LSL #4       ;251
000144  7b1e              LDRB     r6,[r3,#0xc]          ;251
000146  2301              MOVS     r3,#1                 ;251
000148  40b3              LSLS     r3,r3,r6              ;251
00014a  4e0b              LDR      r6,|L4.376|
00014c  eb061600          ADD      r6,r6,r0,LSL #4       ;251
000150  68b6              LDR      r6,[r6,#8]            ;251
000152  6033              STR      r3,[r6,#0]            ;251
000154  bf00              NOP                            ;253
                  |L4.342|
000156  f89d0020          LDRB     r0,[sp,#0x20]         ;256
00015a  4908              LDR      r1,|L4.380|
00015c  eb011000          ADD      r0,r1,r0,LSL #4       ;256
000160  a90a              ADD      r1,sp,#0x28           ;256
000162  c94e              LDM      r1,{r1-r3,r6}         ;256
000164  c04e              STM      r0!,{r1-r3,r6}        ;256
000166  bf00              NOP      
000168  e752              B        |L4.16|
;;;258    
                          ENDP

00016a  0000              DCW      0x0000
                  |L4.364|
00016c  00000000          DCFD     0x4000000000000000 ; 2
000170  40000000
                  |L4.372|
                          DCD      0x40004404
                  |L4.376|
                          DCD      interruptSettings
                  |L4.380|
                          DCD      GPIOIntConfig

                          AREA ||i.GPIOPortA_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortA_Handler PROC
;;;329    
;;;330    void GPIOPortA_Handler(void) { GPIOGeneric_Handler(PIN_A0); }
000000  b510              PUSH     {r4,lr}
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;331    
                          ENDP


                          AREA ||i.GPIOPortB_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortB_Handler PROC
;;;331    
;;;332    void GPIOPortB_Handler(void) { GPIOGeneric_Handler(PIN_B0); }
000000  b510              PUSH     {r4,lr}
000002  2008              MOVS     r0,#8
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;333    
                          ENDP


                          AREA ||i.GPIOPortC_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortC_Handler PROC
;;;333    
;;;334    void GPIOPortC_Handler(void) { GPIOGeneric_Handler(PIN_C0); }
000000  b510              PUSH     {r4,lr}
000002  2010              MOVS     r0,#0x10
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;335    
                          ENDP


                          AREA ||i.GPIOPortD_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortD_Handler PROC
;;;335    
;;;336    void GPIOPortD_Handler(void) { GPIOGeneric_Handler(PIN_D0); }
000000  b510              PUSH     {r4,lr}
000002  2018              MOVS     r0,#0x18
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;337    
                          ENDP


                          AREA ||i.GPIOPortE_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortE_Handler PROC
;;;337    
;;;338    void GPIOPortE_Handler(void) { GPIOGeneric_Handler(PIN_E0); }
000000  b510              PUSH     {r4,lr}
000002  2020              MOVS     r0,#0x20
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.GPIOPortF_Handler||, CODE, READONLY, ALIGN=1

                  GPIOPortF_Handler PROC
;;;339    
;;;340    void GPIOPortF_Handler(void) { GPIOGeneric_Handler(PIN_F0); }
000000  b510              PUSH     {r4,lr}
000002  2028              MOVS     r0,#0x28
000004  f7fffffe          BL       GPIOGeneric_Handler
000008  bd10              POP      {r4,pc}
;;;341    
                          ENDP


                          AREA ||i.GPIOSetBit||, CODE, READONLY, ALIGN=1

                  GPIOSetBit PROC
;;;638     */
;;;639    bool GPIOSetBit(pin_t pin, bool value) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
;;;640        /* Early return on invalid pin_t value. */
;;;641        if (pin >= PIN_COUNT) return false;
000004  2a30              CMP      r2,#0x30
000006  db01              BLT      |L11.12|
000008  2000              MOVS     r0,#0
                  |L11.10|
;;;642    
;;;643        /** 1. Generate the port offset to find the correct addresses.
;;;644         *    There are a couple components in this line:
;;;645         * 
;;;646         *    Note (pin >= PIN_E0). This is a variation of a branchless programming
;;;647         *    technique. See https://www.youtube.com/watch?v=bVJ-mWWL7cE for more
;;;648         *    details.
;;;649         * 
;;;650         *    (((pin - XXX) >> 3) << 12) : 
;;;651         *          Every group of eight pins belongs to the same port, and every
;;;652         *          port has an offset of 0x1000 from each other (typically) (p.685
;;;653         *          in the datasheet). This expression right shifts the pin to mask
;;;654         *          the address (from 0 - 6 | A - F). It then left shifts it to get
;;;655         *          the offset (1 << 12 is 0x1000). This is later appended to
;;;656         *          GPIO_PORT_BASE to get the port address.
;;;657         * 
;;;658         *          The term `- XXX` is a conditional expanded to the following:
;;;659         * 
;;;660         *                        XXX = ((pin >= PIN_E0) << 5)
;;;661         * 
;;;662         *          This conditional is similar to `(pin >= PIN_E0)`. If the pin is 
;;;663         *          in Port E or Port F, we subtract the effective pin by 32 (the 
;;;664         *          enum value of PIN_E0) to get the correct port offset. This is 
;;;665         *          equivalent to 1 << 5, where `(pin >= PIN_E0)` is 1 if true.
;;;666         * 
;;;667         *    + (pin >= PIN_E0) << 17 : 
;;;668         *          Port E and F are special in that they requires an
;;;669         *          extra offset of 0x0002.0000; we add that base offset, which is 
;;;670         *          equivalent to 1 << 7, where `(pin >= PIN_E0)` is 1 if true.
;;;671         */
;;;672        uint32_t portOffset = 
;;;673            (((pin - ((pin >= PIN_E0) << 5)) >> 3) << 12) + ((pin >= PIN_E0) << 17);
;;;674    
;;;675        /* 2. Determine the pin address. I.E. PF1 (41) % 8 = 1. */
;;;676        pin &= 0x07;
;;;677        GET_REG(GPIO_PORT_BASE + portOffset + (1 << (pin + 2))) = value << pin;
;;;678        return true;
;;;679    }
00000a  bd70              POP      {r4-r6,pc}
                  |L11.12|
00000c  2a20              CMP      r2,#0x20              ;672
00000e  db01              BLT      |L11.20|
000010  2001              MOVS     r0,#1                 ;672
000012  e000              B        |L11.22|
                  |L11.20|
000014  2000              MOVS     r0,#0                 ;672
                  |L11.22|
000016  eba21040          SUB      r0,r2,r0,LSL #5       ;672
00001a  10c0              ASRS     r0,r0,#3              ;672
00001c  0300              LSLS     r0,r0,#12             ;672
00001e  2a20              CMP      r2,#0x20              ;672
000020  db01              BLT      |L11.38|
000022  2401              MOVS     r4,#1                 ;672
000024  e000              B        |L11.40|
                  |L11.38|
000026  2400              MOVS     r4,#0                 ;672
                  |L11.40|
000028  eb004344          ADD      r3,r0,r4,LSL #17      ;672
00002c  f0020207          AND      r2,r2,#7              ;676
000030  fa01f002          LSL      r0,r1,r2              ;677
000034  f1032440          ADD      r4,r3,#0x40004000     ;677
000038  1c95              ADDS     r5,r2,#2              ;677
00003a  2601              MOVS     r6,#1                 ;677
00003c  40ae              LSLS     r6,r6,r5              ;677
00003e  51a0              STR      r0,[r4,r6]            ;677
000040  2001              MOVS     r0,#1                 ;678
000042  e7e2              B        |L11.10|
;;;680    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GPIOIntConfig
                          %        768

                          AREA ||.data||, DATA, ALIGN=2

                  interruptSettings
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000000
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000001
000020  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000002
000030  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0xe000e400
                          DCD      0xe000e100
                          DCD      0x00000003
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xe000e404
                          DCD      0xe000e100
                          DCD      0x00000004
000050  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0xe000e41c
                          DCD      0xe000e100
                          DCD      0x0000001e
