; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I.. -I../../.. -IC:\Users\matth\AppData\Local\Arm\Packs\Keil\TM4C_DFP\1.1.0\Device\Include\TM4C123 -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=533 -DTM4C123GH6PM -Drvmdk -DPART_LM4F120H5QR --omf_browse=.\objects\adc.crf ..\..\..\lib\ADC\ADC.c]
                          THUMB

                          AREA ||i.ADCInit||, CODE, READONLY, ALIGN=2

                  ADCInit PROC
;;;36     
;;;37     ADC_t ADCInit(ADCConfig_t adcConfig) {
000000  b533              PUSH     {r0,r1,r4,r5,lr}
000002  b083              SUB      sp,sp,#0xc
;;;38         /* 1. Enable the relevant pin GPIO. */
;;;39         GPIOConfig_t pin = {
000004  4959              LDR      r1,|L1.364|
000006  c903              LDM      r1,{r0,r1}
000008  e9cd0101          STRD     r0,r1,[sp,#4]
00000c  f89d000c          LDRB     r0,[sp,#0xc]
000010  4957              LDR      r1,|L1.368|
000012  5c08              LDRB     r0,[r1,r0]
000014  f88d0004          STRB     r0,[sp,#4]
;;;40             ADCPinMapping[adcConfig.pin],
;;;41             NONE,
;;;42             false,
;;;43             true,
;;;44             0,
;;;45             true
;;;46         };
;;;47         GPIOInit(pin);
000018  e9dd0101          LDRD     r0,r1,[sp,#4]
00001c  f7fffffe          BL       GPIOInit
;;;48     
;;;49         /* 2. Activate the clock for RCGCADC. */
;;;50         GET_REG(SYSCTL_BASE + SYSCTL_RCGCADC_OFFSET) |=
000020  4854              LDR      r0,|L1.372|
000022  6800              LDR      r0,[r0,#0]
000024  f89d200d          LDRB     r2,[sp,#0xd]
000028  2101              MOVS     r1,#1
00002a  4091              LSLS     r1,r1,r2
00002c  4308              ORRS     r0,r0,r1
00002e  4951              LDR      r1,|L1.372|
000030  6008              STR      r0,[r1,#0]
;;;51             1 << adcConfig.module;
;;;52     
;;;53         /* 3. Stall until clock is ready. */
;;;54         while ((GET_REG(SYSCTL_BASE + SYSCTL_PRADC_OFFSET) &
000032  bf00              NOP      
                  |L1.52|
000034  4850              LDR      r0,|L1.376|
000036  6800              LDR      r0,[r0,#0]
000038  f89d200d          LDRB     r2,[sp,#0xd]
00003c  2101              MOVS     r1,#1
00003e  4091              LSLS     r1,r1,r2
000040  4008              ANDS     r0,r0,r1
000042  2800              CMP      r0,#0
000044  d0f6              BEQ      |L1.52|
;;;55             (1 << adcConfig.module)) == 0) {};
;;;56     
;;;57         uint32_t moduleBase = !adcConfig.module * ADC0_BASE + adcConfig.module * ADC1_BASE;
000046  f89d000d          LDRB     r0,[sp,#0xd]
00004a  b908              CBNZ     r0,|L1.80|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L1.82|
                  |L1.80|
000050  2000              MOVS     r0,#0
                  |L1.82|
000052  ebc001c0          RSB      r1,r0,r0,LSL #3
000056  eb0130c0          ADD      r0,r1,r0,LSL #15
00005a  03c0              LSLS     r0,r0,#15
00005c  f89d100d          LDRB     r1,[sp,#0xd]
000060  eb011281          ADD      r2,r1,r1,LSL #6
000064  eb024281          ADD      r2,r2,r1,LSL #18
000068  eba201c1          SUB      r1,r2,r1,LSL #3
00006c  eb003401          ADD      r4,r0,r1,LSL #12
;;;58     	
;;;59         /**
;;;60          * Note: things not touched for now: 
;;;61          * - ADC_IM (interrupts)
;;;62          * - ADC_TSSEL (PWM trigger only)
;;;63          * - ADC_SPC (Sample phase control)
;;;64          * - ADC_PSSI (Sample sequence initiate - startSample func?)
;;;65          * - ADC_DCISC (Digital comparator interrupt status and clear. Not used.)
;;;66          */
;;;67     			
;;;68     	/* 4. Set sample rate to 125ksps. */
;;;69     	GET_REG(moduleBase + ADC_PC) &= ~0xF;
000070  f8d40fc4          LDR      r0,[r4,#0xfc4]
000074  f020000f          BIC      r0,r0,#0xf
000078  f8c40fc4          STR      r0,[r4,#0xfc4]
;;;70     	GET_REG(moduleBase + ADC_PC) |= 0x1;
00007c  f8d40fc4          LDR      r0,[r4,#0xfc4]
000080  f0400001          ORR      r0,r0,#1
000084  f8c40fc4          STR      r0,[r4,#0xfc4]
;;;71     		
;;;72     	/* 5. Set sequencer priority to ss3=0 ... ss0=3. */
;;;73     	GET_REG(moduleBase + ADC_SSPRI) = 0x0123;
000088  f2401023          MOV      r0,#0x123
00008c  6220              STR      r0,[r4,#0x20]
;;;74     			
;;;75         /* 6. Disable sample sequencer. */
;;;76         GET_REG(moduleBase + ADC_ACTSS) &= ~(1 << adcConfig.sequencer);
00008e  6821              LDR      r1,[r4,#0]
000090  f89d200e          LDRB     r2,[sp,#0xe]
000094  2001              MOVS     r0,#1
000096  4090              LSLS     r0,r0,r2
000098  4381              BICS     r1,r1,r0
00009a  6021              STR      r1,[r4,#0]
;;;77     
;;;78         /* 7. Configure conversion trigger option. */
;;;79         GET_REG(moduleBase + ADC_EMUX) &= ~(0xF << (4 * adcConfig.sequencer));
00009c  6960              LDR      r0,[r4,#0x14]
00009e  f89d100e          LDRB     r1,[sp,#0xe]
0000a2  008a              LSLS     r2,r1,#2
0000a4  210f              MOVS     r1,#0xf
0000a6  4091              LSLS     r1,r1,r2
0000a8  4388              BICS     r0,r0,r1
0000aa  6160              STR      r0,[r4,#0x14]
;;;80     	GET_REG(moduleBase + ADC_EMUX) |= (/* TODO: adcConfig.trigger*/ 0 << (4 * adcConfig.sequencer));
0000ac  6960              LDR      r0,[r4,#0x14]
0000ae  f89d100e          LDRB     r1,[sp,#0xe]
0000b2  008a              LSLS     r2,r1,#2
0000b4  2100              MOVS     r1,#0
0000b6  4091              LSLS     r1,r1,r2
0000b8  4308              ORRS     r0,r0,r1
0000ba  6160              STR      r0,[r4,#0x14]
;;;81     
;;;82         /* 8. Configure sample averaging control. */
;;;83         GET_REG(moduleBase + ADC_SAC) = adcConfig.oversampling;
0000bc  f89d0011          LDRB     r0,[sp,#0x11]
0000c0  6320              STR      r0,[r4,#0x30]
;;;84     
;;;85         /* 9. Configure dithering. */
;;;86         GET_REG(moduleBase + ADC_CTL) = adcConfig.isDithered << 6;
0000c2  f89d0012          LDRB     r0,[sp,#0x12]
0000c6  0180              LSLS     r0,r0,#6
0000c8  63a0              STR      r0,[r4,#0x38]
;;;87     	
;;;88     	/* 10. Phase control. */
;;;89     	GET_REG(moduleBase + ADC_SPC) = adcConfig.phase;
0000ca  f89d0013          LDRB     r0,[sp,#0x13]
0000ce  6260              STR      r0,[r4,#0x24]
;;;90     
;;;91         /* . TODO: Interrupt control. */
;;;92     
;;;93         uint32_t sequencerOffset = ADC_SS0 + 0x020 * adcConfig.sequencer;
0000d0  f89d000e          LDRB     r0,[sp,#0xe]
0000d4  0140              LSLS     r0,r0,#5
0000d6  f1000540          ADD      r5,r0,#0x40
;;;94     
;;;95         /* 8. Select sequencer sample input channel. */
;;;96         GET_REG(moduleBase + sequencerOffset + ADC_SSMUX) &= ~(0xF << (4 * adcConfig.position));
0000da  5960              LDR      r0,[r4,r5]
0000dc  f89d100f          LDRB     r1,[sp,#0xf]
0000e0  008a              LSLS     r2,r1,#2
0000e2  210f              MOVS     r1,#0xf
0000e4  4091              LSLS     r1,r1,r2
0000e6  4388              BICS     r0,r0,r1
0000e8  5160              STR      r0,[r4,r5]
;;;97         GET_REG(moduleBase + sequencerOffset + ADC_SSMUX) |= (adcConfig.pin << (4 * adcConfig.position));
0000ea  f89d000c          LDRB     r0,[sp,#0xc]
0000ee  f89d100f          LDRB     r1,[sp,#0xf]
0000f2  0089              LSLS     r1,r1,#2
0000f4  4088              LSLS     r0,r0,r1
0000f6  5961              LDR      r1,[r4,r5]
0000f8  4308              ORRS     r0,r0,r1
0000fa  5160              STR      r0,[r4,r5]
;;;98     
;;;99         /* 9. Set sample sequence control variables. */
;;;100        /* TODO: note that only IEx (interrupt enable), ENDx (sample end of sequence), are asserted. */
;;;101        GET_REG(moduleBase + sequencerOffset + ADC_SSCTL) &= 
0000fc  1960              ADDS     r0,r4,r5
0000fe  6840              LDR      r0,[r0,#4]
000100  f89d100f          LDRB     r1,[sp,#0xf]
000104  008a              LSLS     r2,r1,#2
000106  210f              MOVS     r1,#0xf
000108  4091              LSLS     r1,r1,r2
00010a  4388              BICS     r0,r0,r1
00010c  1961              ADDS     r1,r4,r5
00010e  6048              STR      r0,[r1,#4]
;;;102            ~(0xF << (adcConfig.position << 2));
;;;103        GET_REG(moduleBase + sequencerOffset + ADC_SSCTL) |=
000110  f89d0010          LDRB     r0,[sp,#0x10]
000114  b908              CBNZ     r0,|L1.282|
000116  2001              MOVS     r0,#1
000118  e000              B        |L1.284|
                  |L1.282|
00011a  2000              MOVS     r0,#0
                  |L1.284|
00011c  eb000040          ADD      r0,r0,r0,LSL #1
000120  0040              LSLS     r0,r0,#1
000122  f89d100f          LDRB     r1,[sp,#0xf]
000126  0089              LSLS     r1,r1,#2
000128  4088              LSLS     r0,r0,r1
00012a  1961              ADDS     r1,r4,r5
00012c  6849              LDR      r1,[r1,#4]
00012e  4308              ORRS     r0,r0,r1
000130  1961              ADDS     r1,r4,r5
000132  6048              STR      r0,[r1,#4]
;;;104    		(0b0110 * !adcConfig.isNotEndSample) << (adcConfig.position << 2);
;;;105    
;;;106        /**
;;;107         * Note: these registers are not currently touched for now:
;;;108         * - ADC_SSOP sample sequence operation
;;;109         * - ADC_SSDC sample sequence digital comparator select
;;;110         */
;;;111    
;;;112        /* 8. Reenable ADCACTSS. */ 
;;;113        GET_REG(moduleBase + ADC_ACTSS) |= 1 << adcConfig.sequencer;
000134  6820              LDR      r0,[r4,#0]
000136  f89d200e          LDRB     r2,[sp,#0xe]
00013a  2101              MOVS     r1,#1
00013c  4091              LSLS     r1,r1,r2
00013e  4308              ORRS     r0,r0,r1
000140  6020              STR      r0,[r4,#0]
;;;114    
;;;115        ADC_t adc = {
000142  f89d000c          LDRB     r0,[sp,#0xc]
000146  f88d0000          STRB     r0,[sp,#0]
00014a  f89d000d          LDRB     r0,[sp,#0xd]
00014e  f88d0001          STRB     r0,[sp,#1]
000152  f89d000e          LDRB     r0,[sp,#0xe]
000156  f88d0002          STRB     r0,[sp,#2]
;;;116            adcConfig.pin,
;;;117            adcConfig.module,
;;;118            adcConfig.sequencer
;;;119        };
;;;120    
;;;121        return adc;
00015a  f8bd1000          LDRH     r1,[sp,#0]
00015e  4608              MOV      r0,r1
000160  f89d1002          LDRB     r1,[sp,#2]
000164  ea404001          ORR      r0,r0,r1,LSL #16
;;;122    }
000168  b005              ADD      sp,sp,#0x14
00016a  bd30              POP      {r4,r5,pc}
;;;123    
                          ENDP

                  |L1.364|
                          DCD      ||.constdata||
                  |L1.368|
                          DCD      ADCPinMapping
                  |L1.372|
                          DCD      0x400fe638
                  |L1.376|
                          DCD      0x400fea38

                          AREA ||i.ADCIsOverflow||, CODE, READONLY, ALIGN=1

                  ADCIsOverflow PROC
;;;123    
;;;124    bool ADCIsOverflow(ADC_t adc) {
000000  b510              PUSH     {r4,lr}
;;;125        // ADC_OSTAT
;;;126        // ADC_SSFSTAT
;;;127        HardFault_Handler();
000002  f7fffffe          BL       HardFault_Handler
;;;128        return false;
000006  2000              MOVS     r0,#0
;;;129    }
000008  bd10              POP      {r4,pc}
;;;130    
                          ENDP


                          AREA ||i.ADCIsUnderflow||, CODE, READONLY, ALIGN=1

                  ADCIsUnderflow PROC
;;;130    
;;;131    bool ADCIsUnderflow(ADC_t adc) {
000000  b510              PUSH     {r4,lr}
;;;132        // ADC_USTAT
;;;133        // ADC_SSFSTAT
;;;134        HardFault_Handler();
000002  f7fffffe          BL       HardFault_Handler
;;;135        return false;
000006  2000              MOVS     r0,#0
;;;136    }
000008  bd10              POP      {r4,pc}
;;;137    
                          ENDP


                          AREA ||i.ADCSample||, CODE, READONLY, ALIGN=1

                  ADCSample PROC
;;;137    
;;;138    uint32_t ADCSample(ADC_t adc) {
000000  b531              PUSH     {r0,r4,r5,lr}
;;;139        /** 1. Initiate sampling in the sample sequencers. */
;;;140        uint32_t moduleBase = !adc.module * ADC0_BASE + adc.module * ADC1_BASE;
000002  f89d3001          LDRB     r3,[sp,#1]
000006  b90b              CBNZ     r3,|L4.12|
000008  2301              MOVS     r3,#1
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  2300              MOVS     r3,#0
                  |L4.14|
00000e  ebc304c3          RSB      r4,r3,r3,LSL #3
000012  eb0433c3          ADD      r3,r4,r3,LSL #15
000016  03dc              LSLS     r4,r3,#15
000018  f89d3001          LDRB     r3,[sp,#1]
00001c  eb031583          ADD      r5,r3,r3,LSL #6
000020  eb054583          ADD      r5,r5,r3,LSL #18
000024  eba503c3          SUB      r3,r5,r3,LSL #3
000028  eb043103          ADD      r1,r4,r3,LSL #12
;;;141        GET_REG(moduleBase + ADC_PSSI) |=  1 << adc.sequencer;
00002c  6a8b              LDR      r3,[r1,#0x28]
00002e  f89d5002          LDRB     r5,[sp,#2]
000032  2401              MOVS     r4,#1
000034  40ac              LSLS     r4,r4,r5
000036  4323              ORRS     r3,r3,r4
000038  628b              STR      r3,[r1,#0x28]
;;;142    
;;;143        /** 2. Wait for flag that conversion is done. */
;;;144        while (!(GET_REG(moduleBase + ADC_RIS) & (1 << adc.sequencer))) {}
00003a  bf00              NOP      
                  |L4.60|
00003c  684b              LDR      r3,[r1,#4]
00003e  f89d5002          LDRB     r5,[sp,#2]
000042  2401              MOVS     r4,#1
000044  40ac              LSLS     r4,r4,r5
000046  4023              ANDS     r3,r3,r4
000048  2b00              CMP      r3,#0
00004a  d0f7              BEQ      |L4.60|
;;;145    
;;;146        /** 3. Read result from the FIFO. */
;;;147        uint32_t sequencerOffset = ADC_SS0 + 0x020 * adc.sequencer;
00004c  f89d3002          LDRB     r3,[sp,#2]
000050  015b              LSLS     r3,r3,#5
000052  f1030240          ADD      r2,r3,#0x40
;;;148        uint32_t result = GET_REG(moduleBase + sequencerOffset +  ADC_SSFIFO);
000056  188b              ADDS     r3,r1,r2
000058  6898              LDR      r0,[r3,#8]
;;;149    
;;;150        /** 4. Clear flag. ADC_ISC clear interrupt */
;;;151        GET_REG(moduleBase + ADC_ISC) |= 1 << adc.sequencer;
00005a  68cb              LDR      r3,[r1,#0xc]
00005c  f89d5002          LDRB     r5,[sp,#2]
000060  2401              MOVS     r4,#1
000062  40ac              LSLS     r4,r4,r5
000064  4323              ORRS     r3,r3,r4
000066  60cb              STR      r3,[r1,#0xc]
;;;152    
;;;153        return result;
;;;154    }
000068  bd38              POP      {r3-r5,pc}
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00030001          DCB      0x00,0x03,0x00,0x01
000004  0001              DCB      0x00,0x01

                          AREA ||.data||, DATA, ALIGN=0

                  ADCPinMapping
000000  23222120          DCB      0x23,0x22,0x21,0x20
000004  1b1a1918          DCB      0x1b,0x1a,0x19,0x18
000008  25240c0d          DCB      0x25,0x24,0x0c,0x0d
